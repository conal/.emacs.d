;;-*-coding: utf-8;-*-
(define-abbrev-table 'agda2-mode-abbrev-table
  '(
    ("go=" "  begin
    ?
  ≡⟨⟩
    ?
  ≡⟨ ? ⟩
    ?
  ≡⟨⟩
    ?
  ∎" nil :count 258)
    ("go~" "  begin
    ?
  ≡⟨⟩
    ?
  ≈⟨ ? ⟩
    ?
  ≡⟨⟩
    ?
  ∎" nil :count 89)
   ))

(define-abbrev-table 'c++-mode-abbrev-table
  '(
    ("catch" "catch" c-electric-continued-statement :count 0)
    ("else" "else" c-electric-continued-statement :count 0)
    ("while" "while" c-electric-continued-statement :count 0)
   ))

(define-abbrev-table 'c-mode-abbrev-table
  '(
    ("else" "else" c-electric-continued-statement :count 0)
    ("while" "while" c-electric-continued-statement :count 0)
   ))

(define-abbrev-table 'global-abbrev-table
  '(
    ("a'a" "axis-aligned" nil :count 5)
    ("a'b" "assign-behavior" nil :count 4)
    ("a'cn" "alpha conversion" nil :count 17)
    ("a'ct" "$\\alpha$-convert" nil :count 4)
    ("a'd" "automatic differentiation" nil :count 115)
    ("a'd't" "abstract data type" nil :count 21)
    ("a'd'ts" "abstract data types" nil :count 22)
    ("a'ect" "alpha-equivalence" nil :count 1)
    ("a'ett" "alpha-equivalent" nil :count 1)
    ("a'f" "as follows" nil :count 339)
    ("a'fr" "applicative functor" nil :count 0)
    ("a'g" "attribute grammar" nil :count 2)
    ("a'k'a" "also known as" nil :count 2)
    ("a'k'o" "a kind of" nil :count 1)
    ("a'l" "at least" nil :count 572)
    ("a'o't" "as opposed to" nil :count 66)
    ("a's" "abstract syntax" nil :count 138)
    ("a's't" "abstract syntax tree" nil :count 5)
    ("a's'ts" "abstract syntax trees" nil :count 10)
    ("a'st" "attribute state" nil :count 2)
    ("a't" "abstract type" nil :count 8)
    ("a't'p" "automated theorem proving" nil :count 3)
    ("a'v" "assign-value" nil :count 3)
    ("a'w" "at which" nil :count 19)
    ("a'w'a" "as well as" nil :count 4)
    ("a'w't" "at which time" nil :count 2)
    ("a'wk" "approximately well-kinded" nil :count 1)
    ("a'ws" "approximate well-typedness" nil :count 21)
    ("aa'bb" "axis-aligned bounding box" nil :count 1)
    ("aa'bbs" "axis-aligned bounding boxes" nil :count 2)
    ("ab'i" "abstract interpretation" nil :count 17)
    ("abd" "abstracted" nil :count 22)
    ("abn" "abstraction" nil :count 380)
    ("abns" "abstractions" nil :count 173)
    ("abotu" "about" nil :count 16)
    ("abt" "abstract" nil :count 485)
    ("abtd" "abstracted" nil :count 4)
    ("abtg" "abstracting" nil :count 17)
    ("abts" "abstracts" nil :count 13)
    ("abty" "abstractly" nil :count 17)
    ("acl" "acceptable" nil :count 72)
    ("actg" "accounting" nil :count 3)
    ("actgs" "accountings" nil :count 0)
    ("acy" "acceptability" nil :count 37)
    ("addn" "addition" nil :count 93)
    ("addns" "additions" nil :count 32)
    ("addny" "additionally" nil :count 6)
    ("adl" "additional" nil :count 3)
    ("adly" "additionally" nil :count 3)
    ("adn" "and" nil :count 514)
    ("adnl" "additional" nil :count 275)
    ("adnly" "additionally" nil :count 16)
    ("adny" "additionally" nil :count 3)
    ("adv" "additive" nil :count 1)
    ("agm" "algorithm" nil :count 944)
    ("agmc" "algorithmic" nil :count 34)
    ("agmcs" "algorithmics" nil :count 0)
    ("agmcy" "algorithmically" nil :count 7)
    ("agms" "algorithms" nil :count 473)
    ("agt" "argument" nil :count 1252)
    ("agts" "arguments" nil :count 815)
    ("ahve" "have" nil :count 54)
    ("ajn" "adjunction" nil :count 17)
    ("ajns" "adjunctions" nil :count 6)
    ("ala" "à la" nil :count 3)
    ("alc" "algebraic" nil :count 37)
    ("alcy" "algebraically" nil :count 1)
    ("alhpa" "alpha" nil :count 2)
    ("alt" "absolute" nil :count 96)
    ("altg" "alternating" nil :count 2)
    ("altt" "alternate" nil :count 69)
    ("altts" "alternates" nil :count 1)
    ("alty" "absolutely" nil :count 10)
    ("amn" "animation" nil :count 73)
    ("amns" "animations" nil :count 22)
    ("aot" "as opposed to" nil :count 3)
    ("aot'" "as opposed to" nil :count 7)
    ("ap'f" "applicative functor" nil :count 10)
    ("ap'fs" "applicative functors" nil :count 9)
    ("apbl" "applicable" nil :count 70)
    ("apby" "applicability" nil :count 33)
    ("apg" "applying" nil :count 391)
    ("aph" "approach" nil :count 1117)
    ("aphd" "approached" nil :count 6)
    ("aphg" "approaching" nil :count 8)
    ("aphs" "approaches" nil :count 112)
    ("apn" "application" nil :count 1139)
    ("apns" "applications" nil :count 530)
    ("appt" "appropriate" nil :count 18)
    ("appty" "appropriately" nil :count 1)
    ("aps" "applies" nil :count 86)
    ("apv" "applicative" nil :count 804)
    ("apvl" "approval" nil :count 4)
    ("apvs" "applicatives" nil :count 24)
    ("apvy" "applicatively" nil :count 4)
    ("apy" "apply" nil :count 997)
    ("apyd" "applied" nil :count 390)
    ("apys" "applies" nil :count 137)
    ("arent" "aren't" nil :count 32)
    ("asap'" "as soon as possible" nil :count 2)
    ("asct" "associate" nil :count 4)
    ("asg" "assigning" nil :count 27)
    ("asgd" "assigned" nil :count 16)
    ("asgt" "assignment" nil :count 92)
    ("asgts" "assignments" nil :count 28)
    ("asmn" "assumption" nil :count 146)
    ("asmns" "assumptions" nil :count 62)
    ("asn" "association" nil :count 59)
    ("asns" "associations" nil :count 10)
    ("asrn" "assertion" nil :count 3)
    ("asrns" "assertions" nil :count 0)
    ("ast" "associate" nil :count 79)
    ("astd" "associated" nil :count 342)
    ("astg" "associating" nil :count 21)
    ("astn" "association" nil :count 2)
    ("asts" "associates" nil :count 21)
    ("asty" "associativity" nil :count 17)
    ("asv" "associative" nil :count 111)
    ("asvy" "associativity" nil :count 103)
    ("at's" "attribute state" nil :count 0)
    ("ata" "automata" nil :count 60)
    ("atc" "automatic" nil :count 121)
    ("atcy" "automatically" nil :count 251)
    ("atn" "automaton" nil :count 85)
    ("atr" "architecture" nil :count 140)
    ("atrl" "architectural" nil :count 3)
    ("atrs" "architectures" nil :count 49)
    ("att" "attribute" nil :count 248)
    ("attd" "attributed" nil :count 13)
    ("attr" "attr" nil :count 85)
    ("atts" "attributes" nil :count 222)
    ("aufn" "anti-unification" nil :count 4)
    ("aufr" "anti-unifier" nil :count 1)
    ("aufrs" "anti-unifiers" nil :count 0)
    ("avn" "abbreviation" nil :count 45)
    ("avns" "abbreviations" nil :count 22)
    ("avt" "abbreviate" nil :count 12)
    ("avtd" "abbreviated" nil :count 8)
    ("avtg" "abbreviating" nil :count 0)
    ("avts" "abbreviates" nil :count 3)
    ("axg" "approximating" nil :count 26)
    ("axm" "axiom" nil :count 4)
    ("axms" "axioms" nil :count 22)
    ("axn" "approximation" nil :count 216)
    ("axns" "approximations" nil :count 98)
    ("axt" "approximate" nil :count 106)
    ("axtd" "approximated" nil :count 14)
    ("axtg" "approximating" nil :count 6)
    ("axts" "approximates" nil :count 12)
    ("axty" "approximately" nil :count 5)
    ("axy" "approximately" nil :count 11)
    ("b'b" "bounding box" nil :count 10)
    ("b'bs" "bounding boxes" nil :count 13)
    ("b'cn" "beta-conversion" nil :count 3)
    ("b'f" "breadth-first" nil :count 7)
    ("b'f's" "breadth-first search" nil :count 8)
    ("b'l" "behavior language" nil :count 32)
    ("b'm'o" "by means of" nil :count 2)
    ("b'rc" "beta reduce" nil :count 4)
    ("b'rcd" "beta reduced" nil :count 0)
    ("b'rdt" "beta reduced" nil :count 1)
    ("b'rn" "beta reduction" nil :count 39)
    ("b'rns" "beta reductions" nil :count 6)
    ("b'rnt" "beta reduction" nil :count 22)
    ("b'rt" "beta reduce" nil :count 1)
    ("b'rx" "beta redex" nil :count 7)
    ("b'rxs" "beta redexes" nil :count 5)
    ("b't" "behavior thread" nil :count 12)
    ("b't'w" "by the way" nil :count 31)
    ("b'ts" "behavior threads" nil :count 8)
    ("b'v" "bound variable" nil :count 46)
    ("b'v'h" "bounding volume hierarchy" nil :count 0)
    ("b'v'hs" "bounding volume hierarchies" nil :count 0)
    ("b'vm" "bounding volume" nil :count 4)
    ("b'vms" "bounding volumes" nil :count 9)
    ("b'vs" "bound variables" nil :count 82)
    ("bccc'" "bicartesian closed category" nil :count 1)
    ("bd" "bound" nil :count 123)
    ("bdd" "bounded" nil :count 19)
    ("bdg" "binding" nil :count 188)
    ("bdgs" "bindings" nil :count 85)
    ("bds" "bounds" nil :count 23)
    ("becasue" "because" nil :count 32)
    ("becuase" "because" nil :count 79)
    ("bjn" "bijection" nil :count 61)
    ("bjns" "bijections" nil :count 12)
    ("bjv" "bijective" nil :count 27)
    ("bot'" "⊥" nil :count 73)
    ("btm" "bottom" nil :count 1)
    ("btms" "bottoms" nil :count 1)
    ("bv" "behave" nil :count 1)
    ("bvd" "behaved" nil :count 1)
    ("bvl" "behavioral" nil :count 3)
    ("bvr" "behavior" nil :count 1695)
    ("bvrl" "behavioral" nil :count 5)
    ("bvrr" "Bvr" nil :count 3)
    ("bvrs" "behaviors" nil :count 902)
    ("bvs" "behaves" nil :count 0)
    ("c'b'v" "call-by-value" nil :count 27)
    ("c'b'x" "continuation-based transformation" nil :count 1)
    ("c'c" "cartesian category" nil :count 1)
    ("c'cs" "cartesian categories" nil :count 0)
    ("c'ctn" "collision continuation" nil :count 3)
    ("c'd" "collision detection" nil :count 19)
    ("c'e" "constraint expression" nil :count 2)
    ("c'es" "constraint expressions" nil :count 2)
    ("c'f" "continuous function" nil :count 9)
    ("c'f'l" "context-free language" nil :count 0)
    ("c'f'ls" "context-free languages" nil :count 1)
    ("c'fs" "continuous functions" nil :count 1)
    ("c'g" "computer graphics" nil :count 12)
    ("c'l'p" "constraint logic programming" nil :count 23)
    ("c'o'c" "Calculus of Constructions" nil :count 9)
    ("c'o'm" "calculus on manifolds" nil :count 5)
    ("c'p" "collision prediction" nil :count 47)
    ("c'p's" "continuation-passing style" nil :count 2)
    ("c'r" "collision response" nil :count 5)
    ("c'rs" "conversion rules" nil :count 6)
    ("c's" "concrete syntax" nil :count 14)
    ("c's'e" "common subexpression elimination" nil :count 12)
    ("c's'g" "constructive solid geometry" nil :count 2)
    ("c's'p" "complete set of pre-unifiers" nil :count 0)
    ("c's'u" "complete set of unifiers" nil :count 13)
    ("c's'us" "complete sets of unifiers" nil :count 4)
    ("c't" "category theory" nil :count 107)
    ("c't'c" "compiling to categories" nil :count 17)
    ("c'tc" "category theoretic" nil :count 1)
    ("c'v" "concrete value" nil :count 12)
    ("c'vs" "concrete values" nil :count 18)
    ("cafe'" "café" nil :count 3)
    ("cafe's" "cafés" nil :count 2)
    ("cant" "can't" nil :count 75)
    ("cbl" "combinational" nil :count 94)
    ("cbly" "combinationally" nil :count 2)
    ("cbn" "combination" nil :count 172)
    ("cbns" "combinations" nil :count 40)
    ("cbr" "combinator" nil :count 70)
    ("cbrl" "combinatorial" nil :count 3)
    ("cbrs" "combinators" nil :count 204)
    ("cc'" "cartesian closed" nil :count 0)
    ("ccc'" "cartesian closed category" nil :count 9)
    ("cccs'" "cartesian closed categories" nil :count 18)
    ("ccf'" "closed cartesian functor" nil :count 2)
    ("cci" "calculi" nil :count 25)
    ("ccln" "conclusion" nil :count 125)
    ("cclns" "conclusions" nil :count 53)
    ("ccn" "calculation" nil :count 47)
    ("ccns" "calculations" nil :count 26)
    ("ccs" "calculus" nil :count 193)
    ("cct" "calculate" nil :count 24)
    ("cctg" "calculating" nil :count 7)
    ("ccts" "calculates" nil :count 1)
    ("cdl" "conditional" nil :count 77)
    ("cdls" "conditionals" nil :count 0)
    ("cdly" "conditionally" nil :count 5)
    ("cdmn" "codomain" nil :count 20)
    ("cdn" "condition" nil :count 271)
    ("cdnl" "conditional" nil :count 45)
    ("cdnls" "conditionals" nil :count 45)
    ("cdnly" "conditionally" nil :count 0)
    ("cdns" "conditions" nil :count 112)
    ("cdots'" "⋯" nil :count 4)
    ("cdt" "coordinate" nil :count 50)
    ("cdtd" "coordinated" nil :count 5)
    ("cdtg" "coordinating" nil :count 5)
    ("cdts" "coordinates" nil :count 43)
    ("cfc" "conference" nil :count 75)
    ("cfcs" "conferences" nil :count 12)
    ("cft" "coefficient" nil :count 12)
    ("cfts" "coefficients" nil :count 23)
    ("cgl" "categorical" nil :count 4)
    ("cgly" "categorically" nil :count 1)
    ("cgn" "conjugation" nil :count 11)
    ("cgt" "conjugate" nil :count 1)
    ("cgy" "category" nil :count 3)
    ("cgys" "categories" nil :count 1)
    ("ch'r" "Church-Rosser" nil :count 32)
    ("chagne" "change" nil :count 3)
    ("cidcn" "coinduction" nil :count 1)
    ("cidv" "coinductive" nil :count 10)
    ("circ'" "∘" nil :count 8)
    ("cjn" "conjunction" nil :count 105)
    ("cjns" "conjunctions" nil :count 14)
    ("cjr" "conjecture" nil :count 44)
    ("cjrd" "conjectured" nil :count 2)
    ("cjrs" "conjectures" nil :count 2)
    ("cjv" "conjunctive" nil :count 6)
    ("cjvy" "conjunctively" nil :count 0)
    ("ck" "check" nil :count 487)
    ("ckd" "checked" nil :count 89)
    ("ckg" "checking" nil :count 182)
    ("ckr" "checker" nil :count 2)
    ("cks" "checks" nil :count 19)
    ("clga" "coalgebra" nil :count 3)
    ("clgas" "coalgebras" nil :count 1)
    ("clgc" "coalgebraic" nil :count 10)
    ("clgcy" "coalgebraically" nil :count 1)
    ("cln" "collection" nil :count 450)
    ("clns" "collections" nil :count 63)
    ("cmpn" "composition" nil :count 7)
    ("cmx" "complex" nil :count 6)
    ("cn" "connection" nil :count 248)
    ("cnn'" "convolutional neural network" nil :count 0)
    ("cnns'" "convolutional neural networks" nil :count 0)
    ("cnqy" "consequently" nil :count 0)
    ("cns" "connections" nil :count 75)
    ("cnt" "constant" nil :count 806)
    ("cnts" "constants" nil :count 335)
    ("cnty" "constantly" nil :count 0)
    ("cojt" "cobject" nil :count 2)
    ("cojts" "cobjects" nil :count 3)
    ("commetn" "comment" nil :count 1)
    ("couldnt" "couldn't" nil :count 19)
    ("cpbl" "composable" nil :count 6)
    ("cpby" "composability" nil :count 8)
    ("cpd" "composed" nil :count 10)
    ("cpl" "compositional" nil :count 154)
    ("cply" "compositionally" nil :count 58)
    ("cpn" "composition" nil :count 1140)
    ("cpnl" "compositional" nil :count 85)
    ("cpns" "compositions" nil :count 143)
    ("cpny" "compositionally" nil :count 11)
    ("cps" "compose" nil :count 20)
    ("cpsd" "composed" nil :count 4)
    ("cpsg" "composing" nil :count 13)
    ("cpss" "composes" nil :count 0)
    ("cpt" "component" nil :count 275)
    ("cptl" "computational" nil :count 58)
    ("cptly" "computationally" nil :count 8)
    ("cptn" "computation" nil :count 697)
    ("cptns" "computations" nil :count 263)
    ("cpts" "components" nil :count 262)
    ("cpty" "compositionality" nil :count 13)
    ("cqn" "consequence" nil :count 75)
    ("cqns" "consequences" nil :count 54)
    ("cqny" "consequently" nil :count 9)
    ("cqt" "consequent" nil :count 8)
    ("cqty" "consequently" nil :count 28)
    ("crcn" "corecursion" nil :count 0)
    ("crcv" "corecursive" nil :count 0)
    ("crcvy" "corecursively" nil :count 2)
    ("crd" "correspond" nil :count 180)
    ("crdc" "correspondence" nil :count 158)
    ("crdd" "corresponded" nil :count 27)
    ("crdg" "corresponding" nil :count 512)
    ("crdgy" "correspondingly" nil :count 38)
    ("crdn" "coordination" nil :count 3)
    ("crds" "corresponds" nil :count 147)
    ("crln" "correlation" nil :count 1)
    ("crlns" "correlations" nil :count 0)
    ("cse'" "common subexpression elimination" nil :count 1)
    ("csn" "collision" nil :count 123)
    ("csns" "collisions" nil :count 39)
    ("cst" "construct" nil :count 511)
    ("cstd" "constructed" nil :count 164)
    ("cstg" "constructing" nil :count 194)
    ("cstn" "construction" nil :count 542)
    ("cstns" "constructions" nil :count 48)
    ("csts" "constructs" nil :count 95)
    ("cstv" "constructive" nil :count 28)
    ("cstvy" "constructively" nil :count 11)
    ("csv" "conservative" nil :count 21)
    ("csvy" "conservatively" nil :count 3)
    ("ct" "constraint" nil :count 399)
    ("ct'" "CT" nil :count 6)
    ("ctc'" "compiling to categories" nil :count 28)
    ("ctc''" "compiling-to-categories" nil :count 81)
    ("ctg" "containing" nil :count 31)
    ("ctgs" "contiguous" nil :count 1)
    ("ctn" "continuation" nil :count 141)
    ("ctns" "continuations" nil :count 68)
    ("ctods" "cdots" nil :count 6)
    ("ctr" "constructor" nil :count 529)
    ("ctrs" "constructors" nil :count 278)
    ("cts" "constraints" nil :count 341)
    ("ctsy" "continuously" nil :count 14)
    ("ctus" "continuous" nil :count 504)
    ("ctusy" "continuously" nil :count 44)
    ("ctuy" "continuity" nil :count 20)
    ("ctv" "commutative" nil :count 118)
    ("ctvy" "commutativity" nil :count 38)
    ("cty" "continuity" nil :count 39)
    ("cvbl" "ConstraintVariable" nil :count 2)
    ("cvby" "convertibility" nil :count 42)
    ("cvc" "convenience" nil :count 7)
    ("cvl" "convertible" nil :count 62)
    ("cvln" "convolution" nil :count 307)
    ("cvlnl" "convolutional" nil :count 2)
    ("cvlns" "convolutions" nil :count 5)
    ("cvn" "conversion" nil :count 380)
    ("cvnc" "convenience" nil :count 144)
    ("cvncs" "conveniences" nil :count 0)
    ("cvns" "conversions" nil :count 71)
    ("cvnt" "convenient" nil :count 297)
    ("cvnty" "conveniently" nil :count 31)
    ("cvt" "convert" nil :count 268)
    ("cvtd" "converted" nil :count 59)
    ("cvtg" "converting" nil :count 91)
    ("cvtl" "conventional" nil :count 142)
    ("cvtly" "conventionally" nil :count 6)
    ("cvtn" "convention" nil :count 71)
    ("cvtns" "conventions" nil :count 15)
    ("cvtr" "converter" nil :count 5)
    ("cvtrs" "converters" nil :count 0)
    ("cvts" "converts" nil :count 26)
    ("cx" "context" nil :count 343)
    ("cx'" "cx" nil :count 5)
    ("cx'f" "context-free" nil :count 4)
    ("cx'f'l" "context-free language" nil :count 0)
    ("cx'f'ls" "context-free languages" nil :count 0)
    ("cx's" "context-sensitive" nil :count 1)
    ("cxs" "contexts" nil :count 117)
    ("cz" "characterize" nil :count 2)
    ("d'b" "double buffer" nil :count 1)
    ("d'bd" "double-buffered" nil :count 0)
    ("d'bg" "double buffering" nil :count 4)
    ("d'c" "dependent calculus" nil :count 30)
    ("d'd" "denotational design" nil :count 79)
    ("d'e" "differential equation" nil :count 9)
    ("d'es" "differential equations" nil :count 30)
    ("d'f" "depth-first" nil :count 11)
    ("d'f'p" "differentiable functional programming" nil :count 4)
    ("d'f's" "depth-first search" nil :count 8)
    ("d'f't" "dependent function type" nil :count 1)
    ("d'f'ts" "dependent function types" nil :count 9)
    ("d'i" "de Bruijn index" nil :count 15)
    ("d'is" "de Bruijn indices" nil :count 28)
    ("d'l" "deep learning" nil :count 69)
    ("d'm" "direct manipulation" nil :count 1)
    ("d'o'f" "degree of freedom" nil :count 8)
    ("d'o'fs" "degrees of freedom" nil :count 17)
    ("d'p" "dynamic programming" nil :count 17)
    ("d'p't" "dependent product type" nil :count 0)
    ("d'p'ts" "dependent product types" nil :count 0)
    ("d's" "data structure" nil :count 93)
    ("d's'e'l" "domain-specific embedded language" nil :count 1)
    ("d's'e'ls" "domain-specific embedded languages" nil :count 2)
    ("d's'l" "domain-specific language" nil :count 5)
    ("d's'ls" "domain-specific languages" nil :count 9)
    ("d'sm" "denotational semantics" nil :count 110)
    ("d'ss" "data structures" nil :count 67)
    ("d't" "data type" nil :count 131)
    ("d't'l'c" "dependent typed lambda calculus" nil :count 5)
    ("d'tp" "data type" nil :count 19)
    ("d'tps" "data types" nil :count 11)
    ("d'ts" "data types" nil :count 148)
    ("da'd" "data-driven" nil :count 18)
    ("da'p" "data-parallel" nil :count 1)
    ("dbd" "distributed" nil :count 29)
    ("dbn" "distribution" nil :count 130)
    ("dbns" "distributions" nil :count 114)
    ("dbt" "distribute" nil :count 50)
    ("dbtd" "distributed" nil :count 21)
    ("dbtg" "distributing" nil :count 13)
    ("dbts" "distributes" nil :count 32)
    ("dbv" "distributive" nil :count 45)
    ("dbvy" "distributivity" nil :count 22)
    ("dcb" "describe" nil :count 242)
    ("dcbd" "described" nil :count 465)
    ("dcbg" "describing" nil :count 104)
    ("dcbl" "decidable" nil :count 37)
    ("dcbs" "describes" nil :count 131)
    ("dcbty" "decidability" nil :count 4)
    ("dcln" "declaration" nil :count 83)
    ("dclns" "declarations" nil :count 55)
    ("dcn" "declaration" nil :count 112)
    ("dcns" "declarations" nil :count 82)
    ("dcpd" "decomposed" nil :count 0)
    ("dcpn" "decomposition" nil :count 154)
    ("dcpns" "decompositions" nil :count 17)
    ("dcps" "decompose" nil :count 45)
    ("dcpsg" "decomposing" nil :count 8)
    ("dcpss" "decomposes" nil :count 2)
    ("dct" "document" nil :count 316)
    ("dctd" "documented" nil :count 17)
    ("dctg" "documenting" nil :count 2)
    ("dctn" "documentation" nil :count 148)
    ("dcts" "documents" nil :count 23)
    ("dcty" "discontinuity" nil :count 3)
    ("dctys" "discontinuities" nil :count 1)
    ("dcv" "declarative" nil :count 113)
    ("dcvy" "declaratively" nil :count 10)
    ("ddc" "deduce" nil :count 37)
    ("ddcd" "deduced" nil :count 3)
    ("ddcg" "deducing" nil :count 2)
    ("ddcs" "deduces" nil :count 2)
    ("ddn" "deduction" nil :count 39)
    ("ddns" "deductions" nil :count 11)
    ("ddv" "deductive" nil :count 9)
    ("de'd" "demand-driven" nil :count 18)
    ("depty" "depth" nil :count 5)
    ("df" "define" nil :count 1970)
    ("df'" "df" nil :count 32)
    ("dfbl" "differentiable" nil :count 176)
    ("dfby" "differentiability" nil :count 16)
    ("dfc" "difference" nil :count 331)
    ("dfcg" "differencing" nil :count 3)
    ("dfcs" "differences" nil :count 79)
    ("dfd" "defined" nil :count 1153)
    ("dfg" "defining" nil :count 358)
    ("dfl" "differential" nil :count 61)
    ("dfls" "differentials" nil :count 0)
    ("dfly" "differentially" nil :count 3)
    ("dfn" "definition" nil :count 2229)
    ("dfnl" "definitional" nil :count 8)
    ("dfnly" "definitionally" nil :count 7)
    ("dfns" "definitions" nil :count 1016)
    ("dfny" "definitionally" nil :count 1)
    ("dfrn" "differentiation" nil :count 296)
    ("dfrns" "differentiations" nil :count 2)
    ("dfrt" "differentiate" nil :count 39)
    ("dfrtd" "differentiated" nil :count 13)
    ("dfrts" "differentiates" nil :count 1)
    ("dfs" "defines" nil :count 102)
    ("dft" "different" nil :count 1316)
    ("dftg" "differentiating" nil :count 19)
    ("dfty" "differently" nil :count 122)
    ("dgt" "disagreement" nil :count 1)
    ("di'p" "disagreement pair" nil :count 172)
    ("di'ps" "disagreement pairs" nil :count 168)
    ("di'sq" "disagreement sequence" nil :count 8)
    ("di'sqs" "disagreement sequences" nil :count 0)
    ("didnt" "didn't" nil :count 84)
    ("djn" "disjunction" nil :count 37)
    ("djns" "disjunctions" nil :count 9)
    ("djv" "disjunctive" nil :count 6)
    ("djvy" "disjunctively" nil :count 0)
    ("dlt" "difficult" nil :count 26)
    ("dlty" "difficulty" nil :count 20)
    ("dltys" "difficulties" nil :count 4)
    ("dm't" "domain theory" nil :count 10)
    ("dm'tc" "domain theoretic" nil :count 3)
    ("dmn" "domain" nil :count 310)
    ("dmns" "domains" nil :count 76)
    ("dn" "denotation" nil :count 65)
    ("dnl" "denotational" nil :count 404)
    ("dnly" "denotationally" nil :count 47)
    ("dnn" "denotation" nil :count 152)
    ("dnn'" "dnn" nil :count 5)
    ("dnns" "denotations" nil :count 28)
    ("dns" "denotations" nil :count 12)
    ("dnv" "denotative" nil :count 82)
    ("dnvy" "denotatively" nil :count 1)
    ("doesnt" "doesn't" nil :count 171)
    ("dof'" "degree of freedom" nil :count 6)
    ("dofs'" "degrees of freedom" nil :count 5)
    ("dont" "don't" nil :count 850)
    ("dpc" "dependence" nil :count 32)
    ("dpcn" "decomposition" nil :count 1)
    ("dpd" "depend" nil :count 162)
    ("dpdd" "depended" nil :count 6)
    ("dpdg" "depending" nil :count 102)
    ("dpds" "depends" nil :count 189)
    ("dpt" "dependent" nil :count 441)
    ("dpts" "dependents" nil :count 0)
    ("dpty" "dependently" nil :count 58)
    ("dpv" "disprove" nil :count 1)
    ("dpy" "dependency" nil :count 132)
    ("dpys" "dependencies" nil :count 137)
    ("drfc" "dereference" nil :count 0)
    ("dscn" "description" nil :count 329)
    ("dscns" "descriptions" nil :count 98)
    ("dscrn" "description" nil :count 1)
    ("dscv" "descriptive" nil :count 18)
    ("dstn" "destruction" nil :count 3)
    ("dstr" "destructor" nil :count 1)
    ("dstrs" "destructors" nil :count 0)
    ("dsv" "destructive" nil :count 30)
    ("dsvy" "destructively" nil :count 44)
    ("dtc" "deterministic" nil :count 88)
    ("dtcy" "deterministically" nil :count 3)
    ("dtm" "determinism" nil :count 15)
    ("dtt" "determinate" nil :count 3)
    ("dtv" "derivative" nil :count 700)
    ("dtvs" "derivatives" nil :count 530)
    ("dv" "derive" nil :count 151)
    ("dv'" "dv" nil :count 17)
    ("dvbl" "derivable" nil :count 1)
    ("dvd" "derived" nil :count 145)
    ("dvg" "deriving" nil :count 271)
    ("dvn" "derivation" nil :count 360)
    ("dvnl" "derivational" nil :count 7)
    ("dvns" "derivations" nil :count 80)
    ("dvp" "develop" nil :count 98)
    ("dvpd" "developed" nil :count 90)
    ("dvpg" "developing" nil :count 80)
    ("dvpr" "developer" nil :count 5)
    ("dvprs" "developers" nil :count 10)
    ("dvps" "develops" nil :count 13)
    ("dvs" "derives" nil :count 15)
    ("dvt" "development" nil :count 285)
    ("dvtl" "developmental" nil :count 0)
    ("dvts" "developments" nil :count 15)
    ("e'b'g" "explanation based generalization" nil :count 2)
    ("e'e" "eta expand" nil :count 21)
    ("e'ed" "eta expanded" nil :count 1)
    ("e'eg" "eta expanding" nil :count 1)
    ("e'en" "eta expansion" nil :count 12)
    ("e'ens" "eta expansions" nil :count 1)
    ("e'es" "eta expands" nil :count 1)
    ("e'l'f" "Edinburgh Logical Framework" nil :count 17)
    ("e'o" "each other" nil :count 0)
    ("e'p" "expression procedure" nil :count 4)
    ("e'pmc" "explicitly polymorphic" nil :count 0)
    ("e'pmm" "explicit polymorphism" nil :count 5)
    ("e'ps" "expression procedures" nil :count 3)
    ("e's's" "ERGO Suport System" nil :count 11)
    ("e'u" "equational unification" nil :count 3)
    ("eft" "efficient" nil :count 760)
    ("efty" "efficiently" nil :count 196)
    ("efy" "efficiency" nil :count 313)
    ("eg" "e.g.," nil :count 1327)
    ("elmn" "elimination" nil :count 5)
    ("emt" "element" nil :count 278)
    ("emts" "elements" nil :count 311)
    ("eplg" "extrapolating" nil :count 0)
    ("epln" "extrapolation" nil :count 11)
    ("eplt" "extrapolate" nil :count 1)
    ("eqc" "equivalence" nil :count 64)
    ("eqcs" "equivalences" nil :count 5)
    ("eqn" "equation" nil :count 134)
    ("eqnl" "equational" nil :count 105)
    ("eqnly" "equationally" nil :count 2)
    ("eqns" "equations" nil :count 151)
    ("eqty" "equality" nil :count 64)
    ("eqtys" "equalities" nil :count 0)
    ("equiv'" "≡" nil :count 17)
    ("eqvt" "equivalent" nil :count 132)
    ("eqvts" "equivalents" nil :count 0)
    ("eqvty" "equivalently" nil :count 7)
    ("evetn" "event" nil :count 4)
    ("evetns" "events" nil :count 9)
    ("evt" "environment" nil :count 406)
    ("evtl" "environmental" nil :count 2)
    ("evts" "environments" nil :count 72)
    ("excersize" "exercise" nil :count 2)
    ("exists'" "∃" nil :count 1)
    ("f'a" "functional animation" nil :count 6)
    ("f'b" "frame buffer" nil :count 2)
    ("f'c" "first-class" nil :count 9)
    ("f'cb" "functor combinator" nil :count 1)
    ("f'cbs" "functor combinators" nil :count 0)
    ("f'ctn" "failure continutation" nil :count 5)
    ("f'ctns" "failure continutations" nil :count 0)
    ("f'e" "for example" nil :count 126)
    ("f'f'i" "foreign function interface" nil :count 10)
    ("f'i" "for instance" nil :count 1301)
    ("f'l" "formal language" nil :count 6)
    ("f'o" "first-order" nil :count 47)
    ("f'o'l" "first-order logic" nil :count 8)
    ("f'o'm" "first-order matching" nil :count 1)
    ("f'o'r" "first-order resolution" nil :count 3)
    ("f'o'u" "first-order unification" nil :count 33)
    ("f'o'v" "field of view" nil :count 1)
    ("f'occ" "free-occurrence" nil :count 2)
    ("f'occs" "free-occurrences" nil :count 1)
    ("f'os" "function objects" nil :count 5)
    ("f'p" "functional programming" nil :count 254)
    ("f'p'i" "fixed point induction" nil :count 13)
    ("f'pt" "floating point" nil :count 3)
    ("f'r" "functional reactive" nil :count 0)
    ("f'r'a" "functional reactive animation" nil :count 1)
    ("f'r'p" "functional reactive programming" nil :count 27)
    ("f's" "formal system" nil :count 10)
    ("f's'm" "finite state machine" nil :count 2)
    ("f's'ms" "finite state machines" nil :count 0)
    ("f'ss" "function symbols" nil :count 5)
    ("f't" "future time" nil :count 1)
    ("f't'v" "free type variable" nil :count 2)
    ("f't'vs" "free type variables" nil :count 7)
    ("f'v" "free variable" nil :count 36)
    ("f'v's" "free vector space" nil :count 12)
    ("f'v'ss" "free vector spaces" nil :count 4)
    ("f'vs" "free variables" nil :count 142)
    ("f'x" "for example" nil :count 4)
    ("fbl" "flexible" nil :count 98)
    ("fbly" "flexibly" nil :count 7)
    ("fbty" "flexibility" nil :count 65)
    ("fby" "flexibility" nil :count 42)
    ("fdl" "fundamental" nil :count 172)
    ("fdls" "fundamentals" nil :count 3)
    ("fdly" "fundamentally" nil :count 53)
    ("fdn" "foundation" nil :count 108)
    ("fdnl" "foundational" nil :count 12)
    ("fdns" "foundations" nil :count 33)
    ("ffl" "flex-flex" nil :count 0)
    ("flase" "False" nil :count 2)
    ("fld" "followed" nil :count 72)
    ("flfl" "flexible-flexible" nil :count 166)
    ("flg" "following" nil :count 349)
    ("flrd" "flexible-rigid" nil :count 153)
    ("fls" "follows" nil :count 81)
    ("fltp" "flexible-type" nil :count 2)
    ("fm" "from" nil :count 9519)
    ("fma" "formula" nil :count 133)
    ("fmac" "formulaic" nil :count 1)
    ("fmas" "formulas" nil :count 77)
    ("fml" "formal" nil :count 196)
    ("fmly" "formally" nil :count 43)
    ("fmn" "formulation" nil :count 370)
    ("fmns" "formulations" nil :count 88)
    ("fmt" "formulate" nil :count 129)
    ("fmtd" "formulated" nil :count 28)
    ("fmtg" "formulating" nil :count 28)
    ("fmts" "formulates" nil :count 7)
    ("fmy" "family" nil :count 300)
    ("fmys" "families" nil :count 106)
    ("fn" "function" nil :count 5153)
    ("fnl" "functional" nil :count 1247)
    ("fnls" "functionals" nil :count 18)
    ("fnly" "functionally" nil :count 39)
    ("fns" "functions" nil :count 3614)
    ("fnty" "functionality" nil :count 162)
    ("fo" "of" nil :count 486)
    ("forall'" "∀" nil :count 8)
    ("fqt" "frequent" nil :count 20)
    ("fqty" "frequently" nil :count 23)
    ("fqy" "frequency" nil :count 33)
    ("fqys" "frequencies" nil :count 5)
    ("frechet" "Fréchet" nil :count 13)
    ("frnak" "frank" nil :count 3)
    ("fsm" "formalism" nil :count 27)
    ("fsm'" "fsm" nil :count 5)
    ("fsms" "formalisms " nil :count 1)
    ("ft" "first" nil :count 3870)
    ("fu'v" "future value" nil :count 2)
    ("fu'vs" "future values" nil :count 15)
    ("fvs'" "free vector space" nil :count 1)
    ("fvss'" "free vector spaces" nil :count 2)
    ("fx'p" "fixed point" nil :count 80)
    ("fx'ps" "fixed points" nil :count 67)
    ("fz" "formalize" nil :count 58)
    ("fzd" "formalized" nil :count 13)
    ("fzg" "formalizing" nil :count 24)
    ("fzl" "formalizable" nil :count 0)
    ("fzn" "formalization" nil :count 23)
    ("fzns" "formalizations" nil :count 5)
    ("fzs" "formalizes" nil :count 4)
    ("g''o" "geometric-object" nil :count 3)
    ("g''os" "geometric-objects" nil :count 0)
    ("g'a'f" "graphics application framework" nil :count 7)
    ("g'c" "garbage collection" nil :count 70)
    ("g'cd" "garbage-collected" nil :count 2)
    ("g'cr" "garbage collector" nil :count 2)
    ("g'd" "geometry-dependent" nil :count 5)
    ("g'dc" "geometry-dependence" nil :count 0)
    ("g'e" "geometry expression" nil :count 9)
    ("g'es" "geometry expressions" nil :count 3)
    ("g'f" "generic function" nil :count 2)
    ("g'l" "geometry language" nil :count 27)
    ("g'o" "geometric object" nil :count 56)
    ("g'os" "geometric objects" nil :count 29)
    ("g'p" "general purpose" nil :count 22)
    ("g'pv" "geometric primitive" nil :count 0)
    ("g'pvs" "geometric primitives" nil :count 7)
    ("g'u'i" "graphical user interface" nil :count 0)
    ("g'u'is" "graphical user interfaces" nil :count 1)
    ("gd" "gd" nil :count 42)
    ("gl" "general" nil :count 1566)
    ("glb'" "⊓" nil :count 4)
    ("glty" "generality" nil :count 97)
    ("gltys" "generalities" nil :count 0)
    ("gly" "generally" nil :count 411)
    ("gmc" "geometric" nil :count 173)
    ("gmcy" "geometrically" nil :count 3)
    ("gmr" "grammar" nil :count 73)
    ("gmrs" "grammars" nil :count 14)
    ("gmy" "geometry" nil :count 1470)
    ("gmys" "geometries" nil :count 13)
    ("gn" "generation" nil :count 291)
    ("gnc" "generic" nil :count 116)
    ("gncs" "generics" nil :count 2)
    ("gncy" "generically" nil :count 5)
    ("gns" "generations" nil :count 6)
    ("gnt" "generate" nil :count 4)
    ("gnts" "generates" nil :count 0)
    ("goign" "going" nil :count 37)
    ("gp" "group" nil :count 595)
    ("gpd" "grouping" nil :count 0)
    ("gpg" "grouping" nil :count 1)
    ("gps" "groups" nil :count 73)
    ("grahpics" "graphics" nil :count 7)
    ("gt" "generate" nil :count 360)
    ("gtd" "generated" nil :count 368)
    ("gtg" "generating" nil :count 120)
    ("gtr" "generator" nil :count 84)
    ("gtrs" "generators" nil :count 34)
    ("gts" "generates" nil :count 137)
    ("gz" "generalize" nil :count 687)
    ("gzd" "generalized" nil :count 486)
    ("gzg" "generalizing" nil :count 186)
    ("gzn" "generalization" nil :count 231)
    ("gzns" "generalizations" nil :count 49)
    ("gzs" "generalizes" nil :count 127)
    ("h'e" "hyper-edge" nil :count 1)
    ("h'es" "hyper-edges" nil :count 0)
    ("h'g" "hyper-graph" nil :count 2)
    ("h'gs" "hyper-graphs" nil :count 0)
    ("h'l" "high-level" nil :count 139)
    ("h'n" "head normal" nil :count 2)
    ("h'n'f" "head normal form" nil :count 38)
    ("h'n'fs" "head normal forms" nil :count 2)
    ("h'o" "higher-order" nil :count 437)
    ("h'o'a's" "higher-order abstract syntax" nil :count 5)
    ("h'o'f" "higher-order function" nil :count 16)
    ("h'o'fs" "higher-order functions" nil :count 31)
    ("h'o'h'h" "higher-order hereditary Harrop" nil :count 2)
    ("h'o'l" "higher-order logic" nil :count 56)
    ("h'o'm" "higher-order matching" nil :count 19)
    ("h'o'r" "higher-order resolution" nil :count 4)
    ("h'o't" "higher-order type" nil :count 1)
    ("h'o'ts" "higher-order types" nil :count 9)
    ("h'o'u" "higher-order unification" nil :count 196)
    ("h's'r" "hidden surface removal" nil :count 4)
    ("h'ss" "half spaces" nil :count 0)
    ("hadnt" "hadn't" nil :count 21)
    ("hasnt" "hasn't" nil :count 7)
    ("havent" "haven't" nil :count 47)
    ("hcl" "hierarchical" nil :count 45)
    ("hcly" "hierarchically" nil :count 5)
    ("hcy" "hierarchy" nil :count 51)
    ("hcys" "hierarchies" nil :count 4)
    ("hmc" "homomorphic" nil :count 146)
    ("hmcy" "homomorphically" nil :count 29)
    ("hmm" "homomorphism" nil :count 498)
    ("hmms" "homomorphisms" nil :count 165)
    ("hod'" "higher-order derivative" nil :count 0)
    ("hods'" "higher-order derivatives" nil :count 1)
    ("hof'" "higher-order function" nil :count 16)
    ("hofs'" "higher-order functions" nil :count 31)
    ("hr'd" "higher dimensional" nil :count 0)
    ("hr'l" "higher level" nil :count 65)
    ("hr'ls" "higher levels" nil :count 1)
    ("hte" "the" nil :count 78)
    ("hvae" "have" nil :count 38)
    ("hvr" "however" nil :count 1574)
    ("hwo" "how" nil :count 12)
    ("hymc" "hylomorphic" nil :count 7)
    ("hymm" "hylomorphism" nil :count 6)
    ("hymms" "hylomorphisms" nil :count 7)
    ("hzl" "horizontal" nil :count 40)
    ("hzly" "horizontally" nil :count 13)
    ("i'a" "in addition" nil :count 36)
    ("i'a't" "in addition to" nil :count 153)
    ("i'as" "inherited attributes" nil :count 2)
    ("i'b" "interactive behavior" nil :count 3)
    ("i'bs" "interactive behaviors" nil :count 1)
    ("i'c" "in contrast" nil :count 123)
    ("i'c'o" "in case of" nil :count 2)
    ("i'f" "in fact" nil :count 149)
    ("i'f'f" "if and only if" nil :count 5)
    ("i'f'o" "in favor of" nil :count 93)
    ("i'fe" "indirection-free" nil :count 2)
    ("i'g" "in general" nil :count 280)
    ("i'h" "induction hypothesis" nil :count 8)
    ("i'm'e" "in my experience" nil :count 4)
    ("i'm'o" "in my opinion" nil :count 12)
    ("i'o" "in order" nil :count 23)
    ("i'o'f" "in order for" nil :count 1)
    ("i'o't" "in order to" nil :count 340)
    ("i'o'w" "in other words" nil :count 136)
    ("i'p" "in particular" nil :count 538)
    ("i'pmc" "implicitly polymorphic" nil :count 3)
    ("i'pmm" "implicit polymorphism" nil :count 30)
    ("i'r" "inference rule" nil :count 29)
    ("i'r't" "in response to" nil :count 1)
    ("i'rs" "inference rules" nil :count 38)
    ("i's" "inference system" nil :count 8)
    ("i's'o" "in spite of" nil :count 42)
    ("i'ss" "inference systems" nil :count 0)
    ("i't" "in that" nil :count 19)
    ("i't'o" "in terms of" nil :count 362)
    ("i'v" "improving value" nil :count 35)
    ("i'vb" "instance variable" nil :count 18)
    ("i'vbs" "instance variables" nil :count 40)
    ("i'vs" "improving values" nil :count 23)
    ("i'w" "in which" nil :count 552)
    ("i'w'c" "in which case" nil :count 68)
    ("iat" "in addition to" nil :count 6)
    ("iat'" "in addition to" nil :count 15)
    ("ibvr" "i-behavior" nil :count 3)
    ("ibvrs" "i-behaviors" nil :count 1)
    ("ic'" "in contrast" nil :count 4)
    ("icl" "incremental" nil :count 168)
    ("icly" "incrementally" nil :count 31)
    ("iclz" "incrementalize" nil :count 0)
    ("ict" "increment" nil :count 16)
    ("ict'" "in contrast to" nil :count 5)
    ("icts" "increments" nil :count 0)
    ("icv" "inclusive" nil :count 26)
    ("icvc" "inconvenience" nil :count 1)
    ("icvnc" "inconvenience" nil :count 0)
    ("icvnt" "inconvenient" nil :count 12)
    ("icvy" "inclusively" nil :count 0)
    ("idc" "introduce" nil :count 368)
    ("idcd" "introduced" nil :count 134)
    ("idcg" "introducing" nil :count 158)
    ("idcn" "induction" nil :count 3)
    ("idcs" "introduces" nil :count 65)
    ("idfn" "identification" nil :count 1)
    ("idn" "introduction" nil :count 238)
    ("idns" "introductions" nil :count 11)
    ("idpc" "independence" nil :count 31)
    ("idpt" "independent" nil :count 244)
    ("idpty" "independently" nil :count 83)
    ("idt'" "inductive data type" nil :count 0)
    ("idts'" "inductive data types" nil :count 0)
    ("idtt" "indeterminate" nil :count 5)
    ("idv" "inductive" nil :count 70)
    ("idvy" "inductively" nil :count 15)
    ("idx" "index" nil :count 51)
    ("idxd" "indexed" nil :count 7)
    ("idxg" "indexing" nil :count 3)
    ("idxs" "indices" nil :count 1)
    ("ie" "i.e.," nil :count 1683)
    ("ieft" "inefficient" nil :count 82)
    ("iefty" "inefficiently" nil :count 2)
    ("iefy" "inefficiency" nil :count 32)
    ("iefys" "inefficiencies" nil :count 5)
    ("ieqty" "inequality" nil :count 4)
    ("ieqtys" "inequalities" nil :count 3)
    ("ifbl" "inflexible" nil :count 3)
    ("ifc" "inference" nil :count 173)
    ("ifcs" "inferences" nil :count 5)
    ("iff'" "if and only if" nil :count 0)
    ("ifl" "informal" nil :count 88)
    ("ifly" "informally" nil :count 30)
    ("ifm" "inform" nil :count 23)
    ("ifml" "informal" nil :count 18)
    ("ifmly" "informally" nil :count 16)
    ("ifmy" "informally" nil :count 11)
    ("ifn" "information" nil :count 565)
    ("ifo" "in favor of" nil :count 4)
    ("ifo'" "in favor of" nil :count 10)
    ("ifqt" "infrequent" nil :count 3)
    ("ifqty" "infrequently" nil :count 0)
    ("ift" "infinite" nil :count 529)
    ("ifty" "infinitely" nil :count 84)
    ("igl" "integral" nil :count 106)
    ("igls" "integrals" nil :count 10)
    ("ign" "integration" nil :count 185)
    ("igns" "integrations" nil :count 2)
    ("igt" "integrate" nil :count 40)
    ("igtd" "integrated" nil :count 18)
    ("igtg" "integrating" nil :count 7)
    ("igtr" "integrator" nil :count 1)
    ("igts" "integrates" nil :count 1)
    ("ijn" "injection" nil :count 21)
    ("ijns" "injections" nil :count 16)
    ("ijv" "injective" nil :count 112)
    ("ijvly" "injectively" nil :count 23)
    ("ijvty" "injectivity" nil :count 20)
    ("imc" "isomorphic" nil :count 189)
    ("imc'" "≅" nil :count 9)
    ("imcy" "isomorphically" nil :count 15)
    ("ime'" "in my experience" nil :count 1)
    ("imm" "isomorphism" nil :count 346)
    ("imms" "isomorphisms" nil :count 273)
    ("implies'" "⟹" nil :count 2)
    ("incst" "inconsistent" nil :count 1)
    ("intn" "interaction" nil :count 176)
    ("intns" "interactions" nil :count 21)
    ("intv" "interactive" nil :count 248)
    ("iot" "in order to" nil :count 18)
    ("iot'" "in order to" nil :count 34)
    ("iow" "in other words" nil :count 154)
    ("ipbl" "impossible" nil :count 94)
    ("ipcn" "implication" nil :count 78)
    ("ipcns" "implications" nil :count 45)
    ("ipd" "implemented" nil :count 335)
    ("ipg" "implementing" nil :count 137)
    ("iplg" "interpolating" nil :count 6)
    ("ipln" "interpolation" nil :count 75)
    ("iplns" "interpolations" nil :count 1)
    ("iplt" "interpolate" nil :count 20)
    ("ipltd" "interpolated" nil :count 5)
    ("iplts" "interpolates" nil :count 1)
    ("ipn" "implementation" nil :count 2192)
    ("ipns" "implementations" nil :count 367)
    ("ipr" "implementer" nil :count 8)
    ("iprc" "importance" nil :count 61)
    ("iprs" "implementers" nil :count 6)
    ("iprt" "important" nil :count 795)
    ("iprty" "importantly" nil :count 34)
    ("ipt" "implement" nil :count 605)
    ("iptd" "implemented" nil :count 50)
    ("iptg" "implementing" nil :count 12)
    ("iptl" "implementable" nil :count 4)
    ("iptr" "implementer" nil :count 25)
    ("iptrs" "implementers" nil :count 6)
    ("ipts" "implements" nil :count 61)
    ("iptv" "imperative" nil :count 435)
    ("iptvy" "imperatively" nil :count 12)
    ("ipv" "improve" nil :count 227)
    ("ipvd" "improved" nil :count 138)
    ("ipvg" "improving" nil :count 125)
    ("ipvs" "improves" nil :count 12)
    ("ipvt" "improvement" nil :count 85)
    ("ipvts" "improvements" nil :count 126)
    ("irl" "internal" nil :count 99)
    ("irls" "internals" nil :count 11)
    ("irly" "internally" nil :count 23)
    ("irz" "internalize" nil :count 6)
    ("irzd" "internalized" nil :count 3)
    ("irzs" "internalizes" nil :count 0)
    ("isft" "insufficient" nil :count 5)
    ("isfty" "insufficiently" nil :count 6)
    ("isl" "intensional" nil :count 10)
    ("isn" "intersection" nil :count 48)
    ("isns" "intersections" nil :count 4)
    ("isnt" "isn't" nil :count 59)
    ("iso'" "in spite of" nil :count 1)
    ("isrn" "instruction" nil :count 38)
    ("isrns" "instructions" nil :count 44)
    ("isrv" "instructive" nil :count 2)
    ("ist" "instantiate" nil :count 136)
    ("istd" "instantiated" nil :count 159)
    ("istg" "instantiating" nil :count 49)
    ("istn" "instantiation" nil :count 13)
    ("istns" "instantiations" nil :count 6)
    ("istr'" "I see to recall" nil :count 3)
    ("ists" "instantiates" nil :count 19)
    ("itc" "intutitionistic" nil :count 10)
    ("itcy" "intutitionistically" nil :count 0)
    ("itd" "interested" nil :count 436)
    ("itds" "ill-typedness" nil :count 29)
    ("itfc" "interface" nil :count 935)
    ("itfcd" "interfaced" nil :count 2)
    ("itfcg" "interfacing" nil :count 13)
    ("itfcs" "interfaces" nil :count 219)
    ("itg" "interesting" nil :count 550)
    ("itgy" "interestingly" nil :count 50)
    ("itm" "imitation" nil :count 55)
    ("itme" "item" nil :count 6)
    ("itms" "imitations" nil :count 40)
    ("itn" "itn" nil :count 25)
    ("itnc" "intuitionistic" nil :count 1)
    ("itns" "interactions" nil :count 17)
    ("ito" "in terms of" nil :count 31)
    ("ito'" "in terms of" nil :count 52)
    ("itp" "interpret" nil :count 91)
    ("itpd" "interpreted" nil :count 33)
    ("itpg" "interpreting" nil :count 58)
    ("itpn" "interpretation" nil :count 372)
    ("itpns" "interpretations" nil :count 114)
    ("itpr" "interpreter" nil :count 56)
    ("itprs" "interpreters" nil :count 4)
    ("itps" "interprets" nil :count 5)
    ("itt" "iterate" nil :count 8)
    ("ittd" "iterated" nil :count 1)
    ("ittn" "iteration" nil :count 19)
    ("ittns" "iterations" nil :count 4)
    ("ittv" "iterative" nil :count 22)
    ("ittvy" "iteratively" nil :count 4)
    ("itv" "interactive" nil :count 18)
    ("itvty" "interactivity" nil :count 8)
    ("itvy" "interactively" nil :count 30)
    ("itz" "internalize" nil :count 0)
    ("itzd" "internalized" nil :count 0)
    ("itzg" "internalizing" nil :count 1)
    ("itzn" "internalization" nil :count 2)
    ("itzs" "internalizes" nil :count 0)
    ("iv'a" "interval analysis" nil :count 37)
    ("ivbl" "invertible" nil :count 66)
    ("ivby" "invertibility" nil :count 4)
    ("ivc" "invariance" nil :count 3)
    ("ive" "I've" nil :count 67)
    ("ivl" "interval" nil :count 396)
    ("ivln" "involution" nil :count 4)
    ("ivlns" "involutions" nil :count 0)
    ("ivls" "intervals" nil :count 228)
    ("ivn" "inversion" nil :count 69)
    ("ivns" "inversions" nil :count 6)
    ("ivt" "invariant" nil :count 126)
    ("ivts" "invariants" nil :count 14)
    ("iw'" "in which" nil :count 1)
    ("iwc" "in which case" nil :count 7)
    ("iwc'" "in which case" nil :count 70)
    ("ix" "index" nil :count 389)
    ("ixd" "indexed" nil :count 375)
    ("ixg" "indexing" nil :count 40)
    ("ixs" "indices" nil :count 10)
    ("iz" "initialize" nil :count 30)
    ("izd" "initialized" nil :count 15)
    ("izg" "initializing" nil :count 7)
    ("izn" "initialization" nil :count 44)
    ("izns" "initializations" nil :count 5)
    ("izr" "initializer" nil :count 0)
    ("izrs" "initializers" nil :count 0)
    ("izs" "initializes" nil :count 0)
    ("j'r" "John Reynolds" nil :count 45)
    ("jfd" "justified" nil :count 11)
    ("jfg" "justifying" nil :count 9)
    ("jfn" "justification" nil :count 59)
    ("jfns" "justifications" nil :count 0)
    ("jfy" "justify" nil :count 58)
    ("jfyd" "justified" nil :count 15)
    ("jfyg" "justifying" nil :count 8)
    ("jfys" "justifies" nil :count 11)
    ("joao" "João" nil :count 5)
    ("jsut" "just" nil :count 32)
    ("jt" "judgment" nil :count 41)
    ("jtl" "judgmental" nil :count 10)
    ("jtly" "judgmentally" nil :count 0)
    ("jts" "judgments" nil :count 7)
    ("jxn" "juxtaposition" nil :count 5)
    ("knwo" "know" nil :count 1)
    ("konw" "know" nil :count 18)
    ("l'a" "linear algebra" nil :count 140)
    ("l'c" "lambda calculus" nil :count 52)
    ("l'cs" "lambda-calculi" nil :count 4)
    ("l'cvby" "lambda convertability" nil :count 2)
    ("l'd't" "algebraic data type" nil :count 17)
    ("l'd'ts" "algebraic data types" nil :count 16)
    ("l'e" "lambda expression" nil :count 12)
    ("l'es" "lambda expressions" nil :count 17)
    ("l'f" "Logical Framework" nil :count 4)
    ("l'f'p" "least fixed point" nil :count 18)
    ("l'f'ps" "least fixed points" nil :count 9)
    ("l'h'n'f" "long head normal form" nil :count 6)
    ("l'h's" "left-hand side" nil :count 17)
    ("l'h'ss" "left-hand sides" nil :count 19)
    ("l'l" "low-level" nil :count 61)
    ("l'ls" "lazy lists" nil :count 1)
    ("l'm" "linear map" nil :count 151)
    ("l'm't" "local modeling transform" nil :count 1)
    ("l'm'ts" "local modeling transforms" nil :count 1)
    ("l'ms" "linear maps" nil :count 264)
    ("l'n'f" "long normal form" nil :count 12)
    ("l'o'i" "level of indirection" nil :count 1)
    ("l'p" "logic programming" nil :count 59)
    ("l'p'l" "logic programming language" nil :count 0)
    ("l's'b" "least significant bit" nil :count 1)
    ("l'u'b" "least upper bound" nil :count 6)
    ("l'u'bs" "least upper bounds" nil :count 0)
    ("l'v" "logical variable" nil :count 1)
    ("l'x" "linear transformation" nil :count 17)
    ("l'xs" "linear transformations" nil :count 41)
    ("ladn" "land" nil :count 2)
    ("lambda'" "λ" nil :count 5)
    ("lbenf" "long beta-eta normal form" nil :count 2)
    ("lbepnf" "long beta-eta product normal form" nil :count 3)
    ("lc" "logic" nil :count 388)
    ("lcl" "logical" nil :count 196)
    ("lcly" "logically" nil :count 26)
    ("lcn" "location" nil :count 179)
    ("lcns" "locations" nil :count 121)
    ("lcs" "logics" nil :count 46)
    ("lcy" "logically" nil :count 2)
    ("leqi'" "⊑" nil :count 13)
    ("lfp'" "least fixed point" nil :count 2)
    ("lfps'" "least fixed points" nil :count 0)
    ("lg" "language" nil :count 2152)
    ("lga" "algebra" nil :count 196)
    ("lgas" "algebras" nil :count 10)
    ("lgc" "algebraic" nil :count 216)
    ("lgcy" "algebraically" nil :count 2)
    ("lgs" "languages" nil :count 626)
    ("lhs'" "left-hand side" nil :count 0)
    ("lhss'" "left-hand sides" nil :count 0)
    ("li'c" "linear combination" nil :count 2)
    ("li'cs" "linear combinations" nil :count 0)
    ("liek" "like" nil :count 20)
    ("llambda'" "Λ" nil :count 3)
    ("loh" "Löh" nil :count 1)
    ("lpg" "Lambda-Prolog" nil :count 131)
    ("lppg" "Lambda'pi-Prolog" nil :count 3)
    ("lr'l" "lower level" nil :count 22)
    ("lr'ls" "lower levels" nil :count 3)
    ("lsit" "list" nil :count 4)
    ("ltods" "ldots" nil :count 6)
    ("ltt" "alternate" nil :count 2)
    ("ltv" "alternative" nil :count 624)
    ("ltvs" "alternatives" nil :count 232)
    ("ltvy" "alternatively" nil :count 396)
    ("lub'" "⊔" nil :count 24)
    ("m'c" "modeling coordinate" nil :count 3)
    ("m'c's'p" "minimal complete set of pre-unifiers" nil :count 9)
    ("m'c's'ps" "minimal complete sets of pre-unifiers" nil :count 8)
    ("m'c's'u" "minimal complete set of unifiers" nil :count 19)
    ("m'c's'us" "minimal complete sets of unifiers" nil :count 0)
    ("m'cs" "model coordinates" nil :count 1)
    ("m'd'p" "Markov decision process" nil :count 3)
    ("m'd'ps" "Markov decision processes" nil :count 5)
    ("m'eqn" "multiequation" nil :count 5)
    ("m'eqns" "multiequations" nil :count 4)
    ("m'g'u" "most general unifier" nil :count 12)
    ("m'i" "multiple inheritance" nil :count 8)
    ("m'l" "metalanguage" nil :count 84)
    ("m'ls" "metalanguages" nil :count 6)
    ("m'm" "multimedia" nil :count 15)
    ("m's'b" "most significant bit" nil :count 0)
    ("m't" "multi-threaded" nil :count 2)
    ("m'x" "modeling transform" nil :count 29)
    ("m'xs" "modeling transforms" nil :count 12)
    ("ma'l" "machine learning" nil :count 171)
    ("mabye" "maybe" nil :count 32)
    ("martin-lof" "Martin-Löf" nil :count 0)
    ("mch" "match" nil :count 90)
    ("mchd" "matched" nil :count 5)
    ("mchg" "matching" nil :count 175)
    ("mchr" "matcher" nil :count 5)
    ("mchs" "matches" nil :count 29)
    ("mcn" "mechanism" nil :count 65)
    ("mcns" "mechanisms" nil :count 42)
    ("mfd" "modified" nil :count 6)
    ("mfn" "modification" nil :count 54)
    ("mfns" "modifications" nil :count 23)
    ("mfo" "MediaFlow" nil :count 34)
    ("mfy" "modify" nil :count 66)
    ("mfyd" "modified" nil :count 162)
    ("mfyg" "modifying" nil :count 31)
    ("mfyl" "modifiable" nil :count 13)
    ("mfyr" "modifier" nil :count 4)
    ("mfyrs" "modifiers" nil :count 0)
    ("mfys" "modifies" nil :count 9)
    ("mgmt" "management" nil :count 58)
    ("mgr" "manager" nil :count 4)
    ("mgt" "management" nil :count 1)
    ("ml'" "metalanguage" nil :count 4)
    ("mlc" "meta-logic" nil :count 16)
    ("mlcl" "meta-logical" nil :count 1)
    ("mlpn" "multiplication" nil :count 6)
    ("mls'" "metalanguages" nil :count 1)
    ("mmm" "monomorphism" nil :count 0)
    ("mmms" "monomorphisms" nil :count 0)
    ("mmz" "memoize" nil :count 46)
    ("mmzd" "memoized" nil :count 41)
    ("mmzg" "memoizing" nil :count 21)
    ("mmzn" "memoization" nil :count 135)
    ("mmzs" "memoizes" nil :count 1)
    ("mna" "minima" nil :count 0)
    ("mng" "meaning" nil :count 494)
    ("mngs" "meanings" nil :count 128)
    ("mnm" "minimum" nil :count 1)
    ("mpc" "monomorphic" nil :count 61)
    ("mpln" "multiplication" nil :count 187)
    ("mplns" "multiplications" nil :count 3)
    ("mpm" "monomorphism" nil :count 18)
    ("mpms" "monomorphisms" nil :count 0)
    ("mpn" "multiplication" nil :count 59)
    ("mpns" "multiplications" nil :count 1)
    ("mpv" "multiplicative" nil :count 6)
    ("mpy" "multiply" nil :count 11)
    ("mpyd" "multiplied" nil :count 2)
    ("mpyg" "multiplying" nil :count 4)
    ("mpys" "multiplies " nil :count 2)
    ("mpz" "monomorphize" nil :count 6)
    ("mpzd" "monomorphized" nil :count 2)
    ("mpzg" "monomorphizing" nil :count 1)
    ("mpzn" "monomorphization" nil :count 14)
    ("mroe" "more" nil :count 61)
    ("mtc" "monotonic" nil :count 133)
    ("mtcly" "monotonically" nil :count 21)
    ("mtcy" "monotonicity" nil :count 112)
    ("mtd" "method" nil :count 816)
    ("mtds" "methods" nil :count 487)
    ("mtdy" "methodology" nil :count 81)
    ("mtdys" "methodologies" nil :count 10)
    ("mtg" "meeting" nil :count 513)
    ("mtgs" "meetings" nil :count 48)
    ("mtn" "maintain" nil :count 1)
    ("mustnt" "mustn't" nil :count 5)
    ("mvbl" "meta-variable" nil :count 8)
    ("mvbls" "meta-variables" nil :count 5)
    ("mvl" "motivational" nil :count 7)
    ("mvn" "motivation" nil :count 175)
    ("mvnl" "motivational" nil :count 0)
    ("mvns" "motivations" nil :count 15)
    ("mvr" "moreover" nil :count 364)
    ("mvt" "motivate" nil :count 63)
    ("mvtd" "motivated" nil :count 106)
    ("mvtg" "motivating" nil :count 35)
    ("mvts" "motivates" nil :count 28)
    ("mxa" "maxima" nil :count 4)
    ("mxm" "maximum" nil :count 61)
    ("mxz" "maximize" nil :count 19)
    ("mxzd" "maximized" nil :count 0)
    ("mxzg" "maximizing" nil :count 0)
    ("mxzn" "maximization" nil :count 0)
    ("mxzs" "maximizes" nil :count 2)
    ("mz" "minimize" nil :count 59)
    ("mzd" "minimized" nil :count 10)
    ("mzg" "minimizing" nil :count 8)
    ("mzn" "minimization" nil :count 22)
    ("mzs" "minimizes" nil :count 8)
    ("n'a's'c" "necessary and sufficient condition" nil :count 4)
    ("n'c" "necessary condition" nil :count 5)
    ("n'cs" "necessary conditions" nil :count 0)
    ("n'd" "natural deduction" nil :count 10)
    ("n'f" "normal form" nil :count 143)
    ("n'fs" "normal forms" nil :count 62)
    ("n'n" "natural number" nil :count 4)
    ("n'ns" "natural numbers" nil :count 17)
    ("n's" "non-strict" nil :count 8)
    ("n'x" "natural transformation" nil :count 15)
    ("n'xs" "natural transformations" nil :count 3)
    ("naive'" "naïve" nil :count 22)
    ("naively'" "naïvely" nil :count 5)
    ("naivete" "naïveté" nil :count 3)
    ("naivite" "naïvité" nil :count 1)
    ("nbd" "neighborhood" nil :count 8)
    ("nbds" "neighborhoods" nil :count 3)
    ("nbr" "neighbor" nil :count 2)
    ("nbrs" "neighbors" nil :count 2)
    ("ncly" "necessarily" nil :count 129)
    ("ncpnl" "noncomputational" nil :count 0)
    ("ncts" "noncontinuous" nil :count 1)
    ("ncvby" "nonconvertability" nil :count 1)
    ("ncy" "necessary" nil :count 323)
    ("ndc" "nondeterministic" nil :count 54)
    ("ndcy" "nondeterministically" nil :count 7)
    ("ndm" "nondeterminism" nil :count 33)
    ("ndsv" "non-destructive" nil :count 0)
    ("ndtc" "nondeterministic" nil :count 50)
    ("ndtm" "nondeterminism" nil :count 30)
    ("ne'n" "neural network" nil :count 5)
    ("ne'ns" "neural networks" nil :count 1)
    ("neednt" "needn't" nil :count 42)
    ("nfn" "notification" nil :count 2)
    ("nfnl" "non-functional" nil :count 0)
    ("nfns" "notifications" nil :count 1)
    ("ngv" "negative" nil :count 2)
    ("nicl" "non-incremental" nil :count 0)
    ("nidv" "noninductive" nil :count 2)
    ("nidvy" "noninductively" nil :count 0)
    ("nijv" "non-injective" nil :count 3)
    ("nijvty" "non-injectivity" nil :count 7)
    ("nintv" "non-interactive" nil :count 4)
    ("nitv" "non-interactive" nil :count 20)
    ("nivbl" "non-invertible" nil :count 1)
    ("nixd" "non-indexed" nil :count 15)
    ("njtl" "nonjudgmental" nil :count 4)
    ("njtly" "nonjudgmentally" nil :count 2)
    ("nkow" "know" nil :count 4)
    ("nleqi'" "⋢" nil :count 1)
    ("nmtc" "nonmonotonic" nil :count 3)
    ("noteq'" "≠" nil :count 3)
    ("nsql" "nonsequential" nil :count 0)
    ("nstd" "nonstandard" nil :count 5)
    ("ntcl" "nontechnical" nil :count 1)
    ("ntl" "natural" nil :count 502)
    ("ntls" "naturalness" nil :count 13)
    ("ntly" "naturally" nil :count 159)
    ("ntmn" "non-termination" nil :count 13)
    ("ntmtg" "nonterminating" nil :count 0)
    ("ntn" "notation" nil :count 274)
    ("ntnl" "notational" nil :count 30)
    ("ntns" "notations" nil :count 12)
    ("ntny" "notationally" nil :count 4)
    ("nufby" "nonunifiablity" nil :count 14)
    ("nufl" "nonunifiable" nil :count 19)
    ("nufm" "nonuniform" nil :count 9)
    ("nv'c" "Nonviolent Communication" nil :count 4)
    ("nz" "normalize" nil :count 104)
    ("nzd" "normalized" nil :count 34)
    ("nzg" "normalizing" nil :count 29)
    ("nzl" "normalizable" nil :count 4)
    ("nzn" "normalization" nil :count 116)
    ("nzns" "normalizations" nil :count 1)
    ("nzs" "normalizes" nil :count 3)
    ("nzy" "normalizability" nil :count 26)
    ("o'c" "of course" nil :count 257)
    ("o'd'e" "ordinary differential equation" nil :count 1)
    ("o'd'es" "ordinary differential equations" nil :count 4)
    ("o'f" "objective function" nil :count 0)
    ("o'fs" "objective functions" nil :count 0)
    ("o'l" "object language" nil :count 105)
    ("o'lc" "object logic" nil :count 1)
    ("o'lcs" "object logics" nil :count 1)
    ("o'ls" "object languages" nil :count 16)
    ("o'm" "object model" nil :count 3)
    ("o'ms" "object models" nil :count 0)
    ("o'o" "object-oriented" nil :count 68)
    ("o'o'p" "object-oriented programming" nil :count 0)
    ("o'on" "object-orientation" nil :count 5)
    ("o'p'l'c" "omega-order polymorphic lambda-calculus" nil :count 1)
    ("o's" "object system" nil :count 37)
    ("o's't" "on second thought" nil :count 10)
    ("o'sm" "operational semantics" nil :count 10)
    ("o'ss" "object systems" nil :count 2)
    ("o't" "overloading tool" nil :count 0)
    ("o't'f" "of the form" nil :count 92)
    ("o'tp" "object type" nil :count 17)
    ("o'tps" "object types" nil :count 10)
    ("o'u't" "once upon a time" nil :count 1)
    ("o'w" "of which" nil :count 9)
    ("ocn" "occurrence" nil :count 224)
    ("ocns" "occurrences" nil :count 197)
    ("ocsn" "occlusion" nil :count 13)
    ("odg" "ordering" nil :count 1)
    ("ofr" "for" nil :count 27)
    ("ojn" "objection" nil :count 34)
    ("ojns" "objections" nil :count 24)
    ("ojt" "object" nil :count 885)
    ("ojtd" "objected" nil :count 4)
    ("ojtg" "objecting" nil :count 3)
    ("ojts" "objects" nil :count 679)
    ("ojv" "objective" nil :count 57)
    ("ojvs" "objectives" nil :count 10)
    ("ojvy" "objectively" nil :count 13)
    ("olc" "object-logic" nil :count 7)
    ("olcs" "object-logics" nil :count 3)
    ("olg" "object-language" nil :count 62)
    ("olgs" "object-languages" nil :count 14)
    ("omer" "Ömer" nil :count 8)
    ("opl" "optional" nil :count 148)
    ("oply" "optionally" nil :count 14)
    ("opn" "operation" nil :count 632)
    ("opnl" "operational" nil :count 7)
    ("opns" "operations" nil :count 1020)
    ("opr" "operator" nil :count 274)
    ("oprl" "operational" nil :count 224)
    ("oprly" "operationally" nil :count 39)
    ("oprs" "operators" nil :count 175)
    ("optg" "operating" nil :count 16)
    ("ordg" "ordering" nil :count 23)
    ("ost'" "on second thought" nil :count 12)
    ("ot" "to" nil :count 144)
    ("otf'" "of the form" nil :count 1)
    ("otoh" "on the other hand" nil :count 542)
    ("otp" "object-type" nil :count 16)
    ("otps" "object-types" nil :count 9)
    ("otu" "out" nil :count 5)
    ("ovn" "observation" nil :count 2)
    ("ovns" "observations" nil :count 4)
    ("ovw" "overview" nil :count 23)
    ("owrk" "work" nil :count 5)
    ("ows" "otherwise" nil :count 503)
    ("oz" "optimize" nil :count 174)
    ("ozby" "optimizability" nil :count 4)
    ("ozd" "optimized" nil :count 164)
    ("ozg" "optimizing" nil :count 77)
    ("ozn" "optimization" nil :count 567)
    ("ozns" "optimizations" nil :count 152)
    ("ozr" "optimizer" nil :count 4)
    ("ozs" "optimizes" nil :count 8)
    ("p'a" "partial application" nil :count 2)
    ("p'a'p" "proofs as programs" nil :count 3)
    ("p'a't" "propositions as types" nil :count 1)
    ("p'as" "partial applications" nil :count 0)
    ("p'b" "pattern binder" nil :count 0)
    ("p'c" "predicate calculus" nil :count 6)
    ("p'd" "program derivation" nil :count 14)
    ("p'ds" "program derivations" nil :count 0)
    ("p'e" "partial evaluation" nil :count 53)
    ("p'ed" "partial evaluated" nil :count 1)
    ("p'f" "partial function" nil :count 20)
    ("p'fs" "partial functions" nil :count 19)
    ("p'l" "programming language" nil :count 148)
    ("p'l'c" "polymorphic lambda calculus" nil :count 13)
    ("p'lc" "programmable logic" nil :count 1)
    ("p'ls" "programming languages" nil :count 90)
    ("p'm" "pattern matching" nil :count 64)
    ("p'o" "partial order" nil :count 51)
    ("p'o'v" "point of view" nil :count 35)
    ("p'o'vs" "points of view" nil :count 0)
    ("p'og" "partial ordering" nil :count 3)
    ("p'os" "partial orders" nil :count 5)
    ("p'p" "parametric polymorphism" nil :count 2)
    ("p'p't" "pair-producing type" nil :count 7)
    ("p'p'ts" "pair-producing types" nil :count 5)
    ("p'p'v" "pair-producing variable" nil :count 7)
    ("p'p'vs" "pair-producing variables" nil :count 6)
    ("p'ps" "progressive pairs" nil :count 1)
    ("p'r" "primitive recursion" nil :count 17)
    ("p's" "program synthesis" nil :count 30)
    ("p'ss" "program syntheses" nil :count 1)
    ("p'st" "proper subterm" nil :count 1)
    ("p'v" "program verification" nil :count 11)
    ("p'x" "program transformation" nil :count 90)
    ("p'xs" "program transformations" nil :count 4)
    ("p-eg" "partially evaluating" nil :count 0)
    ("pagm" "pre-algorithm" nil :count 38)
    ("pagms" "pre-algorithms" nil :count 12)
    ("pari" "pair" nil :count 9)
    ("pbl" "possible" nil :count 974)
    ("pbm" "problem" nil :count 1752)
    ("pbmc" "problematic" nil :count 95)
    ("pbms" "problems" nil :count 428)
    ("pbty" "possibility" nil :count 225)
    ("pbtys" "possibilities" nil :count 233)
    ("pbvr" "proto-behavior" nil :count 1)
    ("pbvrs" "proto-behaviors" nil :count 2)
    ("pby" "possibly" nil :count 400)
    ("pcdn" "precondition" nil :count 5)
    ("pcdns" "preconditions" nil :count 2)
    ("pcls" "protocols" nil :count 1)
    ("pcr" "processor" nil :count 3)
    ("pdfd" "predefined" nil :count 7)
    ("pdmn" "predomain" nil :count 13)
    ("pdmns" "predomains" nil :count 16)
    ("pdt" "predicate" nil :count 291)
    ("pdts" "predicates" nil :count 94)
    ("perhpas" "perhaps" nil :count 36)
    ("pf" "proof" nil :count 429)
    ("pfc" "preference" nil :count 86)
    ("pfcs" "preferences" nil :count 47)
    ("pfmc" "performance" nil :count 3)
    ("pfs" "proofs" nil :count 488)
    ("pgm" "program" nil :count 1051)
    ("pgmc" "programmatic" nil :count 14)
    ("pgmcy" "programmatically" nil :count 6)
    ("pgmd" "programmed" nil :count 21)
    ("pgmg" "programming" nil :count 1190)
    ("pgml" "programmable" nil :count 9)
    ("pgmr" "programmer" nil :count 147)
    ("pgmrs" "programmers" nil :count 152)
    ("pgms" "programs" nil :count 619)
    ("pha" "polyhedra" nil :count 1)
    ("phn" "polyhedron" nil :count 20)
    ("phns" "polyhedra" nil :count 6)
    ("pjn" "projection" nil :count 77)
    ("pjns" "projections" nil :count 109)
    ("pjr" "projector" nil :count 2)
    ("pjrs" "projectors" nil :count 0)
    ("pjt" "project" nil :count 579)
    ("pjtd" "projected" nil :count 4)
    ("pjtg" "projecting" nil :count 8)
    ("pjtr" "projector" nil :count 2)
    ("pjtrs" "projectors" nil :count 1)
    ("pjts" "projects" nil :count 127)
    ("pjv" "projective" nil :count 4)
    ("pll" "parallel" nil :count 586)
    ("pllm" "parallelism" nil :count 119)
    ("plln" "parallelization" nil :count 7)
    ("pllz" "parallelize" nil :count 12)
    ("pmc" "polymorphic" nil :count 273)
    ("pmcy" "polymorphically" nil :count 7)
    ("pmgr" "programmer" nil :count 2)
    ("pml" "polynomial" nil :count 28)
    ("pmls" "polynomials" nil :count 34)
    ("pmm" "polymorphism" nil :count 316)
    ("pmn" "permutation" nil :count 44)
    ("pmns" "permutations" nil :count 14)
    ("pmr" "parameter" nil :count 289)
    ("pmrs" "parameters" nil :count 342)
    ("pnc" "permanence" nil :count 14)
    ("pns" "polyhedra" nil :count 28)
    ("pnt" "permanent" nil :count 24)
    ("pnty" "permanently" nil :count 3)
    ("poitn" "point" nil :count 2)
    ("poitns" "points" nil :count 4)
    ("pordg" "preordering" nil :count 2)
    ("ppl" "propositional" nil :count 10)
    ("pply" "propositionally" nil :count 4)
    ("ppn" "proposition" nil :count 125)
    ("ppns" "propositions" nil :count 34)
    ("ppny" "propositionally" nil :count 3)
    ("pptys" "properties" nil :count 4)
    ("pr" "pair" nil :count 161)
    ("pr'd" "probability distribution" nil :count 0)
    ("pr'ds" "probability distributions" nil :count 1)
    ("prby" "probably" nil :count 1806)
    ("prpr" "pair-pair" nil :count 2)
    ("prs" "pairs" nil :count 98)
    ("prtc" "probabilistic" nil :count 73)
    ("prtcy" "probabilistically" nil :count 0)
    ("prty" "probability" nil :count 133)
    ("prtys" "probabilities" nil :count 24)
    ("psn" "position" nil :count 353)
    ("psnl" "positional" nil :count 10)
    ("psns" "positions" nil :count 42)
    ("psv" "positive" nil :count 117)
    ("psvs" "positives" nil :count 4)
    ("psvy" "positively" nil :count 11)
    ("pt" "point" nil :count 1011)
    ("pt'd" "partial derivative" nil :count 1)
    ("pt'ds" "partial derivatives" nil :count 3)
    ("pt'f" "point-free" nil :count 2)
    ("ptc" "parametric" nil :count 69)
    ("ptcr" "particular" nil :count 1)
    ("ptcy" "parametrically" nil :count 30)
    ("ptd" "pointed" nil :count 250)
    ("ptg" "pointing" nil :count 58)
    ("ptl" "partial" nil :count 205)
    ("ptly" "partially" nil :count 53)
    ("ptn" "pattern" nil :count 558)
    ("ptns" "patterns" nil :count 372)
    ("ptr" "pointer" nil :count 193)
    ("ptrs" "pointers" nil :count 107)
    ("pts" "points" nil :count 289)
    ("ptv" "primitive" nil :count 329)
    ("ptvs" "primitives" nil :count 298)
    ("ptvy" "primitively" nil :count 2)
    ("pty" "property" nil :count 665)
    ("ptys" "properties" nil :count 661)
    ("pufby" "pre-unifiability" nil :count 2)
    ("pufl" "pre-unifiable" nil :count 1)
    ("pufn" "pre-unification" nil :count 69)
    ("pufr" "pre-unifier" nil :count 22)
    ("pufrs" "pre-unifiers" nil :count 27)
    ("pufy" "pre-unify" nil :count 1)
    ("pv" "prove" nil :count 479)
    ("pvbl" "provable" nil :count 5)
    ("pvbty" "provability" nil :count 4)
    ("pvby" "provably" nil :count 5)
    ("pvd" "proved" nil :count 141)
    ("pvg" "proving" nil :count 121)
    ("pvr" "prover" nil :count 17)
    ("pvrs" "provers" nil :count 6)
    ("pvs" "previous" nil :count 571)
    ("pvsy" "previously" nil :count 102)
    ("pvt" "private" nil :count 0)
    ("pvw" "preview" nil :count 5)
    ("pz" "parametrize" nil :count 66)
    ("pzd" "parametrized" nil :count 200)
    ("pzg" "parametrizing" nil :count 15)
    ("pzn" "parametrization" nil :count 53)
    ("pzns" "parametrizations" nil :count 0)
    ("pzs" "parametrizes" nil :count 2)
    ("q'c" "equivalence class" nil :count 12)
    ("q'cs" "equivalence classes" nil :count 4)
    ("q'm" "quantum mechanics" nil :count 0)
    ("q'r" "equivalence relation" nil :count 27)
    ("q'rs" "equivalence relations" nil :count 16)
    ("qbl" "questionable" nil :count 13)
    ("qfd" "quantified" nil :count 57)
    ("qfg" "quantifying" nil :count 9)
    ("qfn" "quantification" nil :count 65)
    ("qfns" "quantifications" nil :count 0)
    ("qfr" "quantifier" nil :count 41)
    ("qfrs" "quantifiers" nil :count 73)
    ("qfs" "quantifies" nil :count 1)
    ("qfy" "quantify" nil :count 18)
    ("qfyd" "quantified" nil :count 11)
    ("qlfn" "qualification" nil :count 3)
    ("qlfns" "qualifications" nil :count 0)
    ("qlfr" "qualifier" nil :count 2)
    ("qlfrs" "qualifiers" nil :count 0)
    ("qlty" "quality" nil :count 6)
    ("qltys" "qualities" nil :count 0)
    ("qn" "question" nil :count 1027)
    ("qnd" "questioned" nil :count 3)
    ("qng" "questioning" nil :count 2)
    ("qnl" "equational" nil :count 5)
    ("qns" "questions" nil :count 500)
    ("qt" "quote" nil :count 10)
    ("qtn" "quaternion" nil :count 4)
    ("qtns" "quaternions" nil :count 1)
    ("qts" "quotes" nil :count 2)
    ("qty" "quantity" nil :count 7)
    ("qtys" "quantities" nil :count 3)
    ("qvc" "equivalence" nil :count 129)
    ("qvcs" "equivalences" nil :count 13)
    ("qvt" "equivalent" nil :count 258)
    ("qvts" "equivalents" nil :count 0)
    ("qvty" "equivalently" nil :count 149)
    ("r'a'p" "reasoning about programs" nil :count 2)
    ("r'b" "reactive behavior" nil :count 17)
    ("r'bs" "reactive behaviors" nil :count 29)
    ("r'd'd't" "recursively defined data type" nil :count 2)
    ("r'd'd'ts" "recursively defined data types" nil :count 2)
    ("r'e" "regular expression" nil :count 7)
    ("r'es" "regular expressions" nil :count 41)
    ("r'f" "representable functor" nil :count 22)
    ("r'fs" "representable functors" nil :count 35)
    ("r'h's" "right-hand side" nil :count 24)
    ("r'h'ss" "right-hand sides" nil :count 21)
    ("r'l" "reinforcement learning" nil :count 14)
    ("r'n'f" "reactive normal form" nil :count 3)
    ("r'o" "rigid object" nil :count 0)
    ("r'os" "rigid objects" nil :count 0)
    ("r'p'c" "rigid-path-check" nil :count 2)
    ("r'r" "rewrite rule" nil :count 89)
    ("r'rs" "rewrite rules" nil :count 138)
    ("r't" "referentially transparent" nil :count 10)
    ("r't's" "run-time system" nil :count 6)
    ("r'ty" "referential transparency" nil :count 10)
    ("r'v" "reactive value" nil :count 24)
    ("r'vs" "reactive values" nil :count 56)
    ("r'w" "roughly well-typed" nil :count 2)
    ("rarrow'" "→" nil :count 13)
    ("rastg" "re-associating" nil :count 0)
    ("rbly" "arbitrarily" nil :count 42)
    ("rbml" "RBML" nil :count 85)
    ("rby" "arbitrary" nil :count 379)
    ("rcbn" "recombination" nil :count 1)
    ("rcd" "recommended" nil :count 2)
    ("rcn" "recursion" nil :count 254)
    ("rcns" "recursions" nil :count 31)
    ("rcptn" "recomputation" nil :count 4)
    ("rcst" "reconstruct" nil :count 0)
    ("rcsts" "reconstructs" nil :count 0)
    ("rcv" "recursive" nil :count 505)
    ("rcvy" "recursively" nil :count 167)
    ("rd" "rigid" nil :count 127)
    ("rdby" "reducibility" nil :count 1)
    ("rdc" "reduce" nil :count 170)
    ("rdcd" "reduced" nil :count 40)
    ("rdcg" "reducing" nil :count 67)
    ("rdcl" "reducible" nil :count 1)
    ("rdcs" "reduces" nil :count 29)
    ("rdf" "redefine" nil :count 32)
    ("rdfd" "redefined" nil :count 10)
    ("rdfg" "redefining" nil :count 0)
    ("rdfl" "rigid-flexible" nil :count 54)
    ("rdfn" "redefinition" nil :count 3)
    ("rdfs" "redefines" nil :count 0)
    ("rdn" "reduction" nil :count 193)
    ("rdns" "reductions" nil :count 39)
    ("rdrd" "rigid-rigid" nil :count 150)
    ("rfc" "reference" nil :count 283)
    ("rfcd" "referenced" nil :count 10)
    ("rfcs" "references" nil :count 239)
    ("rfd" "reified" nil :count 9)
    ("rfg" "reifying" nil :count 12)
    ("rfl" "referential" nil :count 13)
    ("rfmn" "reformulation" nil :count 16)
    ("rfmns" "reformulations" nil :count 2)
    ("rfmt" "reformulate" nil :count 17)
    ("rfmtd" "reformulated" nil :count 0)
    ("rfmtg" "reformulating" nil :count 5)
    ("rfn" "reification" nil :count 95)
    ("rfns" "reifications" nil :count 2)
    ("rfr" "reifier" nil :count 1)
    ("rfy" "reify" nil :count 24)
    ("rfys" "reifies" nil :count 5)
    ("rgt" "right" nil :count 3)
    ("rgz" "recognize" nil :count 2)
    ("ridc" "reintroduce" nil :count 2)
    ("ritp" "reinterpret" nil :count 3)
    ("ritpd" "reinterpreted" nil :count 1)
    ("ritpg" "reinterpreting" nil :count 2)
    ("ritpn" "reinterpretation" nil :count 2)
    ("ritpns" "reinterpretations" nil :count 1)
    ("rjn" "rejection" nil :count 1)
    ("rl" "rule" nil :count 312)
    ("rl'" "rl" nil :count 13)
    ("rlcn" "relocation" nil :count 31)
    ("rlcns" "relocations" nil :count 1)
    ("rln" "relation" nil :count 426)
    ("rlnl" "relational" nil :count 26)
    ("rlns" "relations" nil :count 142)
    ("rlp" "relationship" nil :count 257)
    ("rlps" "relationships" nil :count 79)
    ("rls" "rules" nil :count 321)
    ("rpbl" "representable" nil :count 242)
    ("rpc" "replace" nil :count 761)
    ("rpcd" "replaced" nil :count 196)
    ("rpcg" "replacing" nil :count 238)
    ("rpcs" "replaces" nil :count 43)
    ("rpct" "replacement" nil :count 78)
    ("rpcts" "replacements" nil :count 11)
    ("rpn" "representation" nil :count 1496)
    ("rpnl" "representational" nil :count 32)
    ("rpns" "representations" nil :count 552)
    ("rpny" "representationally" nil :count 2)
    ("rpt" "represent" nil :count 464)
    ("rptbl" "representable" nil :count 1)
    ("rptd" "represented" nil :count 281)
    ("rptg" "representing" nil :count 190)
    ("rpts" "represents" nil :count 97)
    ("rptv" "representative" nil :count 7)
    ("rptvs" "representatives" nil :count 1)
    ("rpv" "respective" nil :count 6)
    ("rpvy" "respectively" nil :count 35)
    ("rpzn" "reparametrization" nil :count 3)
    ("rqd" "required" nil :count 247)
    ("rqg" "requiring" nil :count 36)
    ("rqr" "require" nil :count 392)
    ("rqrd" "required" nil :count 22)
    ("rqrg" "requiring" nil :count 58)
    ("rqrs" "requires" nil :count 365)
    ("rqt" "requirement" nil :count 153)
    ("rqts" "requirements" nil :count 113)
    ("rsn" "resolution" nil :count 159)
    ("rsns" "resolutions" nil :count 6)
    ("rtn" "rotation" nil :count 83)
    ("rtnl" "rotational" nil :count 3)
    ("rtns" "rotations" nil :count 20)
    ("rvlt" "re-evaluate" nil :count 2)
    ("rvltd" "re-evaluated" nil :count 0)
    ("rvn" "revolution" nil :count 7)
    ("rvns" "revolutions" nil :count 4)
    ("rvy" "respectively" nil :count 115)
    ("rxps" "re-express" nil :count 2)
    ("s'a" "such as" nil :count 395)
    ("s'c" "sufficient condition" nil :count 24)
    ("s'cs" "sufficient conditions" nil :count 0)
    ("s'ctn" "success continuation" nil :count 62)
    ("s'ctns" "success continuations" nil :count 22)
    ("s'e" "side-effect" nil :count 12)
    ("s'e'c" "semantic editor combinator" nil :count 7)
    ("s'e'cs" "semantic editor combinators" nil :count 7)
    ("s'ec" "syntactic equivalence" nil :count 4)
    ("s'eg" "software engineering" nil :count 8)
    ("s'es" "side-effects" nil :count 18)
    ("s'f" "solved form" nil :count 31)
    ("s'i" "structural induction" nil :count 16)
    ("s'j" "syntactic judgment" nil :count 4)
    ("s'js" "syntactic judgments" nil :count 1)
    ("s'm" "state machine" nil :count 0)
    ("s'ms" "state machines" nil :count 0)
    ("s'n" "strong normalization" nil :count 26)
    ("s'ng" "strongly normalizing" nil :count 7)
    ("s'nz" "strongly normalize" nil :count 4)
    ("s'nzs" "strongly normalizes" nil :count 0)
    ("s'o" "second-order" nil :count 56)
    ("s'o'm" "second-order matching" nil :count 10)
    ("s'o'u" "second-order unification" nil :count 3)
    ("s'p" "special purpose" nil :count 11)
    ("s'p'o" "strict partial order" nil :count 8)
    ("s'p'os" "strict partial orders" nil :count 0)
    ("s'ps" "special predicates" nil :count 1)
    ("s'r" "simplification rule" nil :count 3)
    ("s'rs" "simplification rules" nil :count 2)
    ("s't" "such that" nil :count 353)
    ("s't'c" "simply typed calculus" nil :count 4)
    ("s't'l'c" "simply typed lambda-calculus" nil :count 26)
    ("s't'l's" "same top level structure" nil :count 2)
    ("s't'm" "space-time model" nil :count 6)
    ("s't'ms" "space-time models" nil :count 10)
    ("s'td" "simply typed" nil :count 25)
    ("s'tp" "simple type" nil :count 1)
    ("s'tps" "simple types" nil :count 1)
    ("s'v" "scientific visualization" nil :count 2)
    ("s'x" "specification transformation" nil :count 5)
    ("s'xs" "specification transformations" nil :count 0)
    ("sb'i" "substitution instance" nil :count 0)
    ("sb'is" "substitution instances" nil :count 1)
    ("sbn" "substitution" nil :count 667)
    ("sbns" "substitutions" nil :count 312)
    ("sbt" "substitute" nil :count 93)
    ("sbtd" "substituted" nil :count 29)
    ("sbtg" "substituting" nil :count 33)
    ("sbtn" "subtraction" nil :count 1)
    ("sbts" "substitutes" nil :count 7)
    ("sbty" "substitutivity" nil :count 1)
    ("sbv" "substitutive" nil :count 22)
    ("sbvy" "substitutivity" nil :count 9)
    ("scn" "section" nil :count 921)
    ("scns" "sections" nil :count 99)
    ("scs" "synchronous" nil :count 75)
    ("scsy" "synchronously" nil :count 4)
    ("scz" "synchronize" nil :count 7)
    ("sczd" "synchronized" nil :count 8)
    ("sczg" "synchronizing" nil :count 0)
    ("sczn" "synchronization" nil :count 67)
    ("sczs" "synchronizes" nil :count 0)
    ("sd" "second" nil :count 1364)
    ("sds" "seconds" nil :count 27)
    ("sdvn" "subderivation" nil :count 1)
    ("sdy" "secondly" nil :count 3)
    ("sfc" "specific" nil :count 386)
    ("sfcs" "specifics" nil :count 48)
    ("sfcy" "specifically" nil :count 251)
    ("sfn" "specification" nil :count 940)
    ("sfns" "specifications" nil :count 300)
    ("sft" "sufficient" nil :count 104)
    ("sfty" "sufficiently" nil :count 46)
    ("sfy" "specify" nil :count 254)
    ("sfyd" "specified" nil :count 202)
    ("sfyg" "specifying" nil :count 86)
    ("sfyr" "specifier" nil :count 4)
    ("sfyrs" "specifiers" nil :count 0)
    ("sfys" "specifies" nil :count 23)
    ("sg" "something" nil :count 1767)
    ("sgp" "semigroup" nil :count 6)
    ("sgps" "semigroups" nil :count 3)
    ("sgr" "signature" nil :count 183)
    ("sgrs" "signatures" nil :count 106)
    ("shoudl" "should" nil :count 2)
    ("shouldnt" "shouldn't" nil :count 16)
    ("si" "is" nil :count 4)
    ("siad" "said" nil :count 15)
    ("sicne" "since" nil :count 86)
    ("simeq'" "≃" nil :count 1)
    ("simlify" "simplify" nil :count 1)
    ("sivl" "subinterval" nil :count 1)
    ("sivls" "subintervals" nil :count 2)
    ("sjn" "surjection" nil :count 3)
    ("sjns" "surjections" nil :count 5)
    ("sjt" "subject" nil :count 37)
    ("sjtd" "subjected" nil :count 5)
    ("sjts" "subjects" nil :count 1)
    ("sjv" "subjective" nil :count 20)
    ("sjvy" "subjectively" nil :count 11)
    ("slcn" "selection" nil :count 11)
    ("sln" "solution" nil :count 635)
    ("slns" "solutions" nil :count 179)
    ("smc" "semantic" nil :count 558)
    ("smcs" "semantics" nil :count 1003)
    ("smcy" "semantically" nil :count 133)
    ("smn" "simplification" nil :count 268)
    ("smns" "simplifications" nil :count 64)
    ("smy" "simplify" nil :count 461)
    ("smyd" "simplified" nil :count 168)
    ("smyg" "simplifying" nil :count 125)
    ("smyr" "simplifier" nil :count 42)
    ("smyrs" "simplifiers" nil :count 1)
    ("smys" "simplifies" nil :count 77)
    ("snc" "synthetic" nil :count 73)
    ("sncy" "synthetically" nil :count 2)
    ("sns" "synthesis" nil :count 144)
    ("snss" "syntheses" nil :count 6)
    ("snz" "synthesize" nil :count 73)
    ("snzd" "synthesized" nil :count 33)
    ("snzg" "synthesizing" nil :count 24)
    ("snzs" "synthesizes" nil :count 0)
    ("soem" "some" nil :count 74)
    ("spbm" "subproblem" nil :count 1)
    ("spbms" "subproblems" nil :count 4)
    ("spl" "special" nil :count 467)
    ("spls" "specials" nil :count 5)
    ("sply" "specially" nil :count 25)
    ("spt" "separate" nil :count 3)
    ("sql" "sequential" nil :count 414)
    ("sqly" "sequentially" nil :count 23)
    ("sqn" "sequence" nil :count 442)
    ("sqns" "sequences" nil :count 186)
    ("sqty" "sequentiality" nil :count 94)
    ("srv" "surjective" nil :count 17)
    ("srvly" "surjectively" nil :count 4)
    ("srvty" "surjectivity" nil :count 13)
    ("ssg" "structure-sharing" nil :count 25)
    ("st'" "such that" nil :count 1)
    ("stc" "syntactic" nil :count 143)
    ("stcly" "syntactically" nil :count 0)
    ("stcy" "syntactically" nil :count 19)
    ("std" "standard" nil :count 655)
    ("stds" "standards" nil :count 8)
    ("stdz" "standardize" nil :count 6)
    ("stdzn" "standardization" nil :count 2)
    ("stfd" "satisfied" nil :count 28)
    ("stfg" "satisfying" nil :count 41)
    ("stfl" "satisfiable" nil :count 6)
    ("stfn" "satisfaction" nil :count 41)
    ("stfs" "satisfies" nil :count 20)
    ("stfy" "satisfy" nil :count 78)
    ("stm" "system" nil :count 550)
    ("stmc" "systematic" nil :count 37)
    ("stmcy" "systematically" nil :count 32)
    ("stms" "systems" nil :count 327)
    ("stmt" "statement" nil :count 105)
    ("stmts" "statements" nil :count 43)
    ("sty" "satisfy" nil :count 128)
    ("styd" "satisfied" nil :count 65)
    ("styg" "satisfying" nil :count 55)
    ("stys" "satisfies" nil :count 40)
    ("svl" "several" nil :count 609)
    ("sx" "syntax" nil :count 466)
    ("sxn" "subexpression" nil :count 3)
    ("sxns" "subexpressions" nil :count 0)
    ("sxpn" "s-expression" nil :count 3)
    ("sz" "specialize" nil :count 235)
    ("szd" "specialized" nil :count 201)
    ("szg" "specializing" nil :count 60)
    ("szn" "specialization" nil :count 140)
    ("szns" "specializations" nil :count 62)
    ("szr" "specializer" nil :count 9)
    ("szs" "specializes" nil :count 130)
    ("t'b" "tangent bundle" nil :count 0)
    ("t'bs" "tangent bundles" nil :count 0)
    ("t'c" "type-check" nil :count 9)
    ("t'c'm" "type class morphism" nil :count 16)
    ("t'c'ms" "type class morphisms" nil :count 22)
    ("t'cg" "type checking" nil :count 83)
    ("t'cr" "type checker" nil :count 5)
    ("t'd" "temporal deviation" nil :count 3)
    ("t'f" "the following" nil :count 1445)
    ("t'f'p" "tangible functional programming" nil :count 5)
    ("t'i" "type inference" nil :count 191)
    ("t'id" "type-instantiated" nil :count 9)
    ("t'in" "type-instantiation" nil :count 4)
    ("t'itd" "tolerably ill-typed" nil :count 5)
    ("t'itds" "tolerable ill-typedness" nil :count 0)
    ("t'l" "term language" nil :count 73)
    ("t'l'c" "typed lambda calculus" nil :count 67)
    ("t'l'cs" "typed lambda-calculi" nil :count 4)
    ("t'l'i" "term language interface" nil :count 2)
    ("t'l's" "top level structure" nil :count 28)
    ("t'ls" "term languages" nil :count 4)
    ("t'o" "third-order" nil :count 13)
    ("t'ocn" "term-occurence" nil :count 2)
    ("t'ocns" "term-occurrences" nil :count 1)
    ("t'p" "theorem proving" nil :count 94)
    ("t'pr" "theorem prover" nil :count 3)
    ("t'r" "tail recursive" nil :count 3)
    ("t't" "time transform" nil :count 29)
    ("t'td" "time transformed" nil :count 0)
    ("t'tn" "time transformation" nil :count 22)
    ("t'tns" "time transformations" nil :count 3)
    ("t'ts" "time transforms" nil :count 9)
    ("t'v" "type variable" nil :count 53)
    ("t'vs" "type variables" nil :count 124)
    ("t'w" "to which" nil :count 0)
    ("ta'v" "tangible value" nil :count 5)
    ("ta'vs" "tangible values" nil :count 8)
    ("taht" "that" nil :count 50)
    ("tcl" "technical" nil :count 224)
    ("tcly" "technically" nil :count 14)
    ("tcy" "technology" nil :count 108)
    ("tcys" "technologies" nil :count 6)
    ("td" "third" nil :count 160)
    ("teh" "the" nil :count 1044)
    ("tfr" "therefore" nil :count 159)
    ("tgy" "terminology" nil :count 16)
    ("thats" "that's" nil :count 1)
    ("theres" "there's" nil :count 2)
    ("theri" "their" nil :count 4)
    ("theyve" "they've" nil :count 1)
    ("thm" "theorem" nil :count 177)
    ("thms" "theorems" nil :count 87)
    ("thsi" "this" nil :count 122)
    ("thta" "that" nil :count 26)
    ("thy" "theory" nil :count 273)
    ("thys" "theories" nil :count 23)
    ("tiem" "time" nil :count 81)
    ("tiems" "times" nil :count 15)
    ("times'" "×" nil :count 11)
    ("tm" "term" nil :count 1263)
    ("tm'i" "term inference" nil :count 25)
    ("tml" "terminal" nil :count 19)
    ("tmls" "terminals" nil :count 0)
    ("tmn" "termination" nil :count 95)
    ("tms" "terms" nil :count 1246)
    ("tmt" "terminate" nil :count 44)
    ("tmtd" "terminated" nil :count 13)
    ("tmtg" "terminating" nil :count 14)
    ("tmts" "terminates" nil :count 13)
    ("tmv" "term-variable" nil :count 1)
    ("tnq" "technique" nil :count 268)
    ("tnqs" "techniques" nil :count 203)
    ("top'" "⊤" nil :count 1)
    ("tp" "type" nil :count 6994)
    ("tp'c" "type class" nil :count 6)
    ("tp'cs" "type classes" nil :count 1)
    ("tp'f" "type family" nil :count 9)
    ("tp'fs" "type families" nil :count 2)
    ("tp't" "type theory" nil :count 2)
    ("tpbl" "typable" nil :count 1)
    ("tpd" "typed" nil :count 429)
    ("tpg" "typing" nil :count 359)
    ("tpgs" "typings" nil :count 19)
    ("tpl" "tuple" nil :count 11)
    ("tps" "types" nil :count 2960)
    ("tptp" "type-type" nil :count 4)
    ("tr'c" "transitive closure" nil :count 2)
    ("ty'c" "type class" nil :count 9)
    ("ty'cs" "type classes" nil :count 1)
    ("u'c" "unification context" nil :count 36)
    ("u'cs" "unification contexts" nil :count 3)
    ("u'e" "unification equivalent" nil :count 5)
    ("u'i" "user interface" nil :count 21)
    ("u'in" "user interaction" nil :count 1)
    ("u'is" "user interfaces" nil :count 4)
    ("u'l" "unification logic" nil :count 5)
    ("u'p" "unification problem" nil :count 151)
    ("u'ps" "unification problems" nil :count 142)
    ("u'q" "universal quantification" nil :count 5)
    ("u'qd" "universally quantified" nil :count 0)
    ("ucdl" "unconditional" nil :count 0)
    ("ucvtl" "unconventional" nil :count 5)
    ("udcbl" "undecidable" nil :count 8)
    ("udfd" "undefined" nil :count 849)
    ("ufby" "unifiability" nil :count 104)
    ("ufd" "unified" nil :count 66)
    ("ufg" "unifying" nil :count 90)
    ("ufl" "unifiable" nil :count 63)
    ("ufm" "uniform" nil :count 119)
    ("ufms" "uniforms" nil :count 1)
    ("ufmy" "uniformly" nil :count 16)
    ("ufn" "unification" nil :count 691)
    ("ufns" "unifications" nil :count 13)
    ("ufr" "unifier" nil :count 222)
    ("ufrs" "unifiers" nil :count 190)
    ("ufs" "unifies" nil :count 54)
    ("ufy" "unify" nil :count 119)
    ("ufys" "unifies" nil :count 6)
    ("uiprt" "unimportant" nil :count 15)
    ("uitd" "uninterested" nil :count 0)
    ("uitg" "uninteresting" nil :count 9)
    ("uizd" "uninitialized" nil :count 2)
    ("uncly" "unnecessarily" nil :count 43)
    ("uncy" "unnecessary" nil :count 140)
    ("unq" "unique" nil :count 1)
    ("untl" "unnatural" nil :count 15)
    ("untly" "unnaturally" nil :count 0)
    ("uozd" "unoptimized" nil :count 5)
    ("upvd" "unproved" nil :count 0)
    ("usfbl" "unsatisfiable" nil :count 3)
    ("ustyd" "unsatisfied" nil :count 2)
    ("ustyg" "unsatisfying" nil :count 2)
    ("utpd" "untyped" nil :count 18)
    ("uvfyd" "unverified" nil :count 0)
    ("uvl" "universal" nil :count 200)
    ("uvls" "universals" nil :count 19)
    ("uvltd" "unevaluated" nil :count 3)
    ("uvly" "universally" nil :count 22)
    ("uvy" "universally" nil :count 18)
    ("v'b" "variable binding" nil :count 0)
    ("v'd" "virtual device" nil :count 8)
    ("v'ds" "virtual devices" nil :count 1)
    ("v'm" "virtual machine" nil :count 11)
    ("v'ms" "virtual machines" nil :count 2)
    ("v'p" "view point" nil :count 5)
    ("v'r" "virtual reality" nil :count 5)
    ("v's" "vector space" nil :count 69)
    ("v'ss" "vector spaces" nil :count 94)
    ("v't" "virtual trackball" nil :count 9)
    ("v'w" "virtual world" nil :count 14)
    ("v'ws" "virtual worlds" nil :count 9)
    ("v'x" "viewing transform" nil :count 18)
    ("v'xs" "viewing transforms" nil :count 2)
    ("vbl" "variable" nil :count 1025)
    ("vbls" "variables" nil :count 841)
    ("vfcn" "verification" nil :count 2)
    ("vfd" "verified" nil :count 17)
    ("vfg" "verifying" nil :count 4)
    ("vfl" "verifiable" nil :count 0)
    ("vfn" "verification" nil :count 57)
    ("vfy" "verify" nil :count 55)
    ("vfyd" "verified" nil :count 48)
    ("vfyg" "verifying" nil :count 1)
    ("vfyr" "verifier" nil :count 0)
    ("vfyrs" "verifiers" nil :count 0)
    ("vfys" "verifies" nil :count 3)
    ("vln" "evaluation" nil :count 333)
    ("vlns" "evaluations" nil :count 26)
    ("vlt" "evaluate" nil :count 102)
    ("vltd" "evaluated" nil :count 70)
    ("vltg" "evaluating" nil :count 51)
    ("vlts" "evaluates" nil :count 20)
    ("vpt" "viewpoint" nil :count 18)
    ("vpts" "viewpoints" nil :count 0)
    ("vrml" "VRML" nil :count 23)
    ("vsl" "visual" nil :count 3)
    ("vsn" "version" nil :count 1377)
    ("vsns" "versions" nil :count 309)
    ("vtm" "variable-term" nil :count 39)
    ("vtp" "variable-type" nil :count 3)
    ("vvtm" "virtual-variable-term" nil :count 0)
    ("vz" "visualize" nil :count 19)
    ("vzd" "visualized" nil :count 6)
    ("vzg" "visualizing" nil :count 14)
    ("vzn" "visualization" nil :count 47)
    ("vzns" "visualizations" nil :count 25)
    ("vzr" "visualizer" nil :count 1)
    ("vzrs" "visualizers" nil :count 2)
    ("vzs" "visualizes" nil :count 1)
    ("w'c" "world coordinate" nil :count 3)
    ("w'cs" "world coordinates" nil :count 1)
    ("w'd" "well-defined" nil :count 1)
    ("w'f" "well formed" nil :count 12)
    ("w'f'o" "well founded ordering" nil :count 7)
    ("w'f'os" "well founded orderings" nil :count 1)
    ("w'fs" "well formedness" nil :count 3)
    ("w'h'n'f" "weak head normal form" nil :count 10)
    ("w'h'r" "weak head reduction" nil :count 1)
    ("w'l'g" "without loss of generality" nil :count 6)
    ("w'p" "word processing" nil :count 3)
    ("w'r't" "with respect to" nil :count 119)
    ("w'v" "weakly valid" nil :count 2)
    ("w'w" "with which" nil :count 3)
    ("waht" "what" nil :count 29)
    ("wasnt" "wasn't" nil :count 21)
    ("wch" "which" nil :count 6062)
    ("wdfd" "well-defined" nil :count 20)
    ("werent" "weren't" nil :count 7)
    ("weve" "we've" nil :count 15)
    ("wh" "with" nil :count 17059)
    ("whehter" "whether" nil :count 16)
    ("whn" "within" nil :count 8)
    ("wiht" "with" nil :count 2)
    ("wkdd" "well-kinded" nil :count 7)
    ("wnat" "want" nil :count 14)
    ("wo" "without" nil :count 1565)
    ("wont" "won't" nil :count 49)
    ("wont'" "wont" nil :count 3)
    ("woudl" "would" nil :count 20)
    ("wouldnt" "wouldn't" nil :count 44)
    ("wrok" "work" nil :count 12)
    ("wroking" "working" nil :count 2)
    ("wrt'" "with respect to" nil :count 9)
    ("wtbl" "well-typable" nil :count 1)
    ("wtd" "well-typed" nil :count 295)
    ("wtds" "well-typedness" nil :count 31)
    ("x'p" "transformation path" nil :count 3)
    ("x'ps" "transformation paths" nil :count 1)
    ("x'q" "existential quantification" nil :count 6)
    ("x'qd" "existentially quantified" nil :count 0)
    ("x'r" "transformation rule" nil :count 29)
    ("x'rs" "transformation rules" nil :count 72)
    ("x's" "transformation system" nil :count 7)
    ("xcv" "exclusive" nil :count 32)
    ("xcvy" "exclusively" nil :count 0)
    ("xfbl" "transformable" nil :count 3)
    ("xfd" "transformed" nil :count 63)
    ("xfg" "transforming" nil :count 61)
    ("xfl" "transformational" nil :count 12)
    ("xfm" "transform" nil :count 495)
    ("xfmd" "transformed" nil :count 10)
    ("xfmg" "transforming" nil :count 11)
    ("xfmr" "transformer" nil :count 2)
    ("xfms" "transforms" nil :count 145)
    ("xfn" "transformation" nil :count 849)
    ("xfnl" "transformational" nil :count 4)
    ("xfns" "transformations" nil :count 389)
    ("xfr" "transformer" nil :count 44)
    ("xfrs" "transformers" nil :count 23)
    ("xln" "translation" nil :count 409)
    ("xlnl" "translational" nil :count 0)
    ("xlns" "translations" nil :count 39)
    ("xlt" "translate" nil :count 171)
    ("xltd" "translated" nil :count 38)
    ("xltg" "translating" nil :count 44)
    ("xltn" "translation" nil :count 2)
    ("xltr" "translator" nil :count 12)
    ("xlts" "translates" nil :count 11)
    ("xn" "transition" nil :count 185)
    ("xnl" "transitional" nil :count 2)
    ("xns" "transitions" nil :count 46)
    ("xpl" "example" nil :count 1448)
    ("xpln" "explanation" nil :count 238)
    ("xplns" "explanations" nil :count 35)
    ("xpls" "examples" nil :count 969)
    ("xpn" "expression" nil :count 723)
    ("xpnl" "exponential" nil :count 0)
    ("xpns" "expressions" nil :count 598)
    ("xps" "express" nil :count 273)
    ("xpsd" "expressed" nil :count 190)
    ("xpsg" "expressing" nil :count 61)
    ("xpsl" "expressible" nil :count 1)
    ("xpss" "expresses" nil :count 2)
    ("xpsv" "expressive" nil :count 12)
    ("xpv" "expressive" nil :count 47)
    ("xpvs" "expressiveness" nil :count 28)
    ("xrl" "external" nil :count 104)
    ("xrly" "externally" nil :count 10)
    ("xrz" "externalize" nil :count 7)
    ("xrzd" "externalized" nil :count 1)
    ("xrzg" "externalizing" nil :count 0)
    ("xrzn" "externalization" nil :count 8)
    ("xrzs" "externalizes" nil :count 0)
    ("xsl" "extensional" nil :count 34)
    ("xslty" "extensionality" nil :count 3)
    ("xsly" "extensionally" nil :count 19)
    ("xsty" "extensionality" nil :count 9)
    ("xtbl" "extensible" nil :count 49)
    ("xtby" "extensibility" nil :count 24)
    ("xtc" "existence" nil :count 34)
    ("xtd" "extend" nil :count 245)
    ("xtdd" "extended" nil :count 153)
    ("xtdg" "extending" nil :count 89)
    ("xtds" "extends" nil :count 76)
    ("xtg" "existing" nil :count 184)
    ("xtl" "existential" nil :count 50)
    ("xtls" "existentials" nil :count 8)
    ("xtly" "existentially" nil :count 50)
    ("xtn" "extension" nil :count 234)
    ("xtns" "extensions" nil :count 148)
    ("xtv" "extensive" nil :count 11)
    ("xtvy" "extensively" nil :count 4)
    ("youd" "you'd" nil :count 1)
    ("youre" "you're" nil :count 4)
    ("youve" "you've" nil :count 8)
   ))

(define-abbrev-table 'haskell-mode-abbrev-table
  '(
    ("Td" "Td" nil :count 4)
    ("alt" "Alt" nil :count 2)
    ("df" "df" nil :count 30)
    ("fo" "fo" nil :count 8)
   ))

(define-abbrev-table 'tex-mode-abbrev-table
  '(
    ("a'cn" "$\\alpha$ conversion" nil :count 52)
    ("a'ec" "$\\alpha$ equivalence" nil :count 13)
    ("a'et" "$\\alpha$ equivalent" nil :count 5)
    ("b'cn" "$\\beta$ conversion" nil :count 3)
    ("b'nf" "$\\beta$ normal form" nil :count 31)
    ("b'r" "$\\beta$ reduce" nil :count 9)
    ("b'rd" "$\\beta$ reduced" nil :count 3)
    ("b'rn" "$\\beta$ reduction" nil :count 32)
    ("be'nf" "$\\beta\\eta$ normal form" nil :count 8)
    ("benf" "$\\beta\\eta$ normal form" nil :count 27)
    ("benfs" "$\\beta\\eta$ normal forms" nil :count 4)
    ("d't'l'c" "dependent typed $\\lambda$ calculus" nil :count 1)
    ("e'e" "$\\eta$ expand" nil :count 15)
    ("e'ed" "$\\eta$ expanded" nil :count 3)
    ("e'en" "$\\eta$ expansion" nil :count 22)
    ("e'rn" "$\\eta$ reduction" nil :count 11)
    ("gd" "gd" nil :count 17)
    ("ith'" "$i$th" nil :count 19)
    ("l'c" "$\\lambda$ calculus" nil :count 43)
    ("l'cs" "$\\lambda$ calculi" nil :count 9)
    ("l'cvby" "$\\lambda$ convertability" nil :count 4)
    ("l'ec" "$\\lambda$ equivalence" nil :count 2)
    ("l'mm" "$\\lambda$ morphism" nil :count 3)
    ("l'mms" "$\\lambda$ morphisms" nil :count 5)
    ("lbehnf" "long $\\beta\\eta$ normal form" nil :count 8)
    ("lbenf" "long $\\beta\\eta$ normal form" nil :count 18)
    ("lbepnf" "long $\\beta\\eta$ product normal form" nil :count 3)
    ("lcvn" "$\\lambda$ conversion" nil :count 1)
    ("lfhnf" "$\\lambda$-free head normal form" nil :count 6)
    ("lpg" "$\\lambda$Prolog" nil :count 34)
    ("lppg" "$\\Lpi$Prolog" nil :count 1)
    ("ltm" "$\\lambda$ term" nil :count 1)
    ("ltms" "$\\lambda$ terms" nil :count 1)
    ("o'p'l'c" "$\\omega$-order polymorphic $\\lambda$ calculus" nil :count 7)
    ("p'l'c" "polymorphic $\\lambda$ calculus" nil :count 19)
    ("s't'l'c" "simply typed $\\lambda$ calculus" nil :count 45)
    ("t'l'c" "typed $\\lambda$ calculus" nil :count 35)
    ("t'l'cs" "typed $\\lambda$ calculi" nil :count 8)
   ))

